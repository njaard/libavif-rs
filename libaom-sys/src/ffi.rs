/* automatically generated by rust-bindgen 0.66.1 */

pub const AOM_IMAGE_ABI_VERSION: u32 = 9;
pub const AOM_IMG_FMT_PLANAR: u32 = 256;
pub const AOM_IMG_FMT_UV_FLIP: u32 = 512;
pub const AOM_IMG_FMT_HIGHBITDEPTH: u32 = 2048;
pub const AOM_HAVE_IMG_FMT_NV12: u32 = 1;
pub const AOM_PLANE_PACKED: u32 = 0;
pub const AOM_PLANE_Y: u32 = 0;
pub const AOM_PLANE_U: u32 = 1;
pub const AOM_PLANE_V: u32 = 2;
pub const AOM_CODEC_ABI_VERSION: u32 = 16;
pub const AOM_CODEC_CAP_DECODER: u32 = 1;
pub const AOM_CODEC_CAP_ENCODER: u32 = 2;
pub const AOM_FRAME_IS_KEY: u32 = 1;
pub const AOM_FRAME_IS_DROPPABLE: u32 = 2;
pub const AOM_FRAME_IS_INTRAONLY: u32 = 16;
pub const AOM_FRAME_IS_SWITCH: u32 = 32;
pub const AOM_FRAME_IS_ERROR_RESILIENT: u32 = 64;
pub const AOM_FRAME_IS_DELAYED_RANDOM_ACCESS_POINT: u32 = 128;
pub const AOM_EXT_PART_ABI_VERSION: u32 = 8;
pub const AOM_EXT_PART_SIZE_DIRECT_SPLIT: u32 = 17;
pub const AOM_EXT_PART_SIZE_PRUNE_PART: u32 = 25;
pub const AOM_EXT_PART_SIZE_PRUNE_NONE: u32 = 4;
pub const AOM_EXT_PART_SIZE_TERM_NONE: u32 = 28;
pub const AOM_EXT_PART_SIZE_TERM_SPLIT: u32 = 31;
pub const AOM_EXT_PART_SIZE_PRUNE_RECT: u32 = 9;
pub const AOM_EXT_PART_SIZE_PRUNE_AB: u32 = 10;
pub const AOM_EXT_PART_SIZE_PRUNE_4_WAY: u32 = 18;
pub const AOM_ENCODER_ABI_VERSION: u32 = 29;
pub const AOM_CODEC_CAP_PSNR: u32 = 65536;
pub const AOM_CODEC_CAP_HIGHBITDEPTH: u32 = 262144;
pub const AOM_CODEC_USE_PSNR: u32 = 65536;
pub const AOM_CODEC_USE_HIGHBITDEPTH: u32 = 262144;
pub const AOM_ERROR_RESILIENT_DEFAULT: u32 = 1;
pub const AOM_EFLAG_FORCE_KF: u32 = 1;
pub const AOM_USAGE_GOOD_QUALITY: u32 = 0;
pub const AOM_USAGE_REALTIME: u32 = 1;
pub const AOM_USAGE_ALL_INTRA: u32 = 2;
pub const AOM_MAXIMUM_WORK_BUFFERS: u32 = 8;
pub const AOM_MAXIMUM_REF_BUFFERS: u32 = 8;
pub const AOM_DECODER_ABI_VERSION: u32 = 22;
pub const AOM_CODEC_CAP_EXTERNAL_FRAME_BUFFER: u32 = 2097152;
pub const AOM_EFLAG_NO_REF_LAST: u32 = 65536;
pub const AOM_EFLAG_NO_REF_LAST2: u32 = 131072;
pub const AOM_EFLAG_NO_REF_LAST3: u32 = 262144;
pub const AOM_EFLAG_NO_REF_GF: u32 = 524288;
pub const AOM_EFLAG_NO_REF_ARF: u32 = 1048576;
pub const AOM_EFLAG_NO_REF_BWD: u32 = 2097152;
pub const AOM_EFLAG_NO_REF_ARF2: u32 = 4194304;
pub const AOM_EFLAG_NO_UPD_LAST: u32 = 8388608;
pub const AOM_EFLAG_NO_UPD_GF: u32 = 16777216;
pub const AOM_EFLAG_NO_UPD_ARF: u32 = 33554432;
pub const AOM_EFLAG_NO_UPD_ENTROPY: u32 = 67108864;
pub const AOM_EFLAG_NO_REF_FRAME_MVS: u32 = 134217728;
pub const AOM_EFLAG_ERROR_RESILIENT: u32 = 268435456;
pub const AOM_EFLAG_SET_S_FRAME: u32 = 536870912;
pub const AOM_EFLAG_SET_PRIMARY_REF_NONE: u32 = 1073741824;
pub const AOM_MAX_SEGMENTS: u32 = 8;
pub const AOM_MAX_LAYERS: u32 = 32;
pub const AOM_MAX_SS_LAYERS: u32 = 4;
pub const AOM_MAX_TS_LAYERS: u32 = 8;
pub const AOM_MAX_TILE_COLS: u32 = 64;
pub const AOM_MAX_TILE_ROWS: u32 = 64;
extern "C" {
    pub fn aom_uleb_size_in_bytes(value: u64) -> usize;
}
extern "C" {
    pub fn aom_uleb_decode(
        buffer: *const u8,
        available: usize,
        value: *mut u64,
        length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aom_uleb_encode(
        value: u64,
        available: usize,
        coded_value: *mut u8,
        coded_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aom_uleb_encode_fixed_size(
        value: u64,
        available: usize,
        pad_to_size: usize,
        coded_value: *mut u8,
        coded_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub const AOM_IMG_FMT_NONE: aom_img_fmt = 0;
pub const AOM_IMG_FMT_YV12: aom_img_fmt = 769;
pub const AOM_IMG_FMT_I420: aom_img_fmt = 258;
pub const AOM_IMG_FMT_AOMYV12: aom_img_fmt = 771;
#[doc = "planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_AOMI420: aom_img_fmt = 260;
#[doc = "planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I422: aom_img_fmt = 261;
#[doc = "planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I444: aom_img_fmt = 262;
pub const AOM_IMG_FMT_NV12: aom_img_fmt = 263;
pub const AOM_IMG_FMT_I42016: aom_img_fmt = 2306;
pub const AOM_IMG_FMT_YV1216: aom_img_fmt = 2817;
pub const AOM_IMG_FMT_I42216: aom_img_fmt = 2309;
pub const AOM_IMG_FMT_I44416: aom_img_fmt = 2310;
#[doc = "List of supported image formats"]
pub type aom_img_fmt = ::std::os::raw::c_uint;
#[doc = "List of supported image formats"]
pub use self::aom_img_fmt as aom_img_fmt_t;
#[doc = "For future use"]
pub const AOM_CICP_CP_RESERVED_0: aom_color_primaries = 0;
#[doc = "BT.709"]
pub const AOM_CICP_CP_BT_709: aom_color_primaries = 1;
#[doc = "Unspecified"]
pub const AOM_CICP_CP_UNSPECIFIED: aom_color_primaries = 2;
#[doc = "For future use"]
pub const AOM_CICP_CP_RESERVED_3: aom_color_primaries = 3;
#[doc = "BT.470 System M (historical)"]
pub const AOM_CICP_CP_BT_470_M: aom_color_primaries = 4;
#[doc = "BT.470 System B, G (historical)"]
pub const AOM_CICP_CP_BT_470_B_G: aom_color_primaries = 5;
#[doc = "BT.601"]
pub const AOM_CICP_CP_BT_601: aom_color_primaries = 6;
#[doc = "SMPTE 240"]
pub const AOM_CICP_CP_SMPTE_240: aom_color_primaries = 7;
pub const AOM_CICP_CP_GENERIC_FILM: aom_color_primaries = 8;
#[doc = "BT.2020, BT.2100"]
pub const AOM_CICP_CP_BT_2020: aom_color_primaries = 9;
#[doc = "SMPTE 428 (CIE 1921 XYZ)"]
pub const AOM_CICP_CP_XYZ: aom_color_primaries = 10;
#[doc = "SMPTE RP 431-2"]
pub const AOM_CICP_CP_SMPTE_431: aom_color_primaries = 11;
#[doc = "SMPTE EG 432-1"]
pub const AOM_CICP_CP_SMPTE_432: aom_color_primaries = 12;
#[doc = "For future use (values 13 - 21)"]
pub const AOM_CICP_CP_RESERVED_13: aom_color_primaries = 13;
#[doc = "EBU Tech. 3213-E"]
pub const AOM_CICP_CP_EBU_3213: aom_color_primaries = 22;
#[doc = "For future use (values 23 - 255)"]
pub const AOM_CICP_CP_RESERVED_23: aom_color_primaries = 23;
#[doc = "List of supported color primaries"]
pub type aom_color_primaries = ::std::os::raw::c_uint;
#[doc = "List of supported color primaries"]
pub use self::aom_color_primaries as aom_color_primaries_t;
#[doc = "For future use"]
pub const AOM_CICP_TC_RESERVED_0: aom_transfer_characteristics = 0;
#[doc = "BT.709"]
pub const AOM_CICP_TC_BT_709: aom_transfer_characteristics = 1;
#[doc = "Unspecified"]
pub const AOM_CICP_TC_UNSPECIFIED: aom_transfer_characteristics = 2;
#[doc = "For future use"]
pub const AOM_CICP_TC_RESERVED_3: aom_transfer_characteristics = 3;
#[doc = "BT.470 System M (historical)"]
pub const AOM_CICP_TC_BT_470_M: aom_transfer_characteristics = 4;
#[doc = "BT.470 System B, G (historical)"]
pub const AOM_CICP_TC_BT_470_B_G: aom_transfer_characteristics = 5;
#[doc = "BT.601"]
pub const AOM_CICP_TC_BT_601: aom_transfer_characteristics = 6;
#[doc = "SMPTE 240 M"]
pub const AOM_CICP_TC_SMPTE_240: aom_transfer_characteristics = 7;
#[doc = "Linear"]
pub const AOM_CICP_TC_LINEAR: aom_transfer_characteristics = 8;
#[doc = "Logarithmic (100 : 1 range)"]
pub const AOM_CICP_TC_LOG_100: aom_transfer_characteristics = 9;
pub const AOM_CICP_TC_LOG_100_SQRT10: aom_transfer_characteristics = 10;
#[doc = "IEC 61966-2-4"]
pub const AOM_CICP_TC_IEC_61966: aom_transfer_characteristics = 11;
#[doc = "BT.1361"]
pub const AOM_CICP_TC_BT_1361: aom_transfer_characteristics = 12;
#[doc = "sRGB or sYCC"]
pub const AOM_CICP_TC_SRGB: aom_transfer_characteristics = 13;
#[doc = "BT.2020 10-bit systems"]
pub const AOM_CICP_TC_BT_2020_10_BIT: aom_transfer_characteristics = 14;
#[doc = "BT.2020 12-bit systems"]
pub const AOM_CICP_TC_BT_2020_12_BIT: aom_transfer_characteristics = 15;
#[doc = "SMPTE ST 2084, ITU BT.2100 PQ"]
pub const AOM_CICP_TC_SMPTE_2084: aom_transfer_characteristics = 16;
#[doc = "SMPTE ST 428"]
pub const AOM_CICP_TC_SMPTE_428: aom_transfer_characteristics = 17;
#[doc = "BT.2100 HLG, ARIB STD-B67"]
pub const AOM_CICP_TC_HLG: aom_transfer_characteristics = 18;
#[doc = "For future use (values 19-255)"]
pub const AOM_CICP_TC_RESERVED_19: aom_transfer_characteristics = 19;
#[doc = "List of supported transfer functions"]
pub type aom_transfer_characteristics = ::std::os::raw::c_uint;
#[doc = "List of supported transfer functions"]
pub use self::aom_transfer_characteristics as aom_transfer_characteristics_t;
#[doc = "Identity matrix"]
pub const AOM_CICP_MC_IDENTITY: aom_matrix_coefficients = 0;
#[doc = "BT.709"]
pub const AOM_CICP_MC_BT_709: aom_matrix_coefficients = 1;
#[doc = "Unspecified"]
pub const AOM_CICP_MC_UNSPECIFIED: aom_matrix_coefficients = 2;
#[doc = "For future use"]
pub const AOM_CICP_MC_RESERVED_3: aom_matrix_coefficients = 3;
#[doc = "US FCC 73.628"]
pub const AOM_CICP_MC_FCC: aom_matrix_coefficients = 4;
#[doc = "BT.470 System B, G (historical)"]
pub const AOM_CICP_MC_BT_470_B_G: aom_matrix_coefficients = 5;
#[doc = "BT.601"]
pub const AOM_CICP_MC_BT_601: aom_matrix_coefficients = 6;
#[doc = "SMPTE 240 M"]
pub const AOM_CICP_MC_SMPTE_240: aom_matrix_coefficients = 7;
#[doc = "YCgCo"]
pub const AOM_CICP_MC_SMPTE_YCGCO: aom_matrix_coefficients = 8;
pub const AOM_CICP_MC_BT_2020_NCL: aom_matrix_coefficients = 9;
#[doc = "BT.2020 constant luminance"]
pub const AOM_CICP_MC_BT_2020_CL: aom_matrix_coefficients = 10;
#[doc = "SMPTE ST 2085 YDzDx"]
pub const AOM_CICP_MC_SMPTE_2085: aom_matrix_coefficients = 11;
pub const AOM_CICP_MC_CHROMAT_NCL: aom_matrix_coefficients = 12;
#[doc = "Chromaticity-derived constant luminance"]
pub const AOM_CICP_MC_CHROMAT_CL: aom_matrix_coefficients = 13;
#[doc = "BT.2100 ICtCp"]
pub const AOM_CICP_MC_ICTCP: aom_matrix_coefficients = 14;
#[doc = "For future use (values 15-255)"]
pub const AOM_CICP_MC_RESERVED_15: aom_matrix_coefficients = 15;
#[doc = "List of supported matrix coefficients"]
pub type aom_matrix_coefficients = ::std::os::raw::c_uint;
#[doc = "List of supported matrix coefficients"]
pub use self::aom_matrix_coefficients as aom_matrix_coefficients_t;
#[doc = "<- Y  [16..235],  UV  [16..240]  (bit depth 8) */\n/**<- Y  [64..940],  UV  [64..960]  (bit depth 10) */\n/**<- Y [256..3760], UV [256..3840] (bit depth 12)"]
pub const AOM_CR_STUDIO_RANGE: aom_color_range = 0;
#[doc = "<- YUV/RGB [0..255]  (bit depth 8) */\n/**<- YUV/RGB [0..1023] (bit depth 10) */\n/**<- YUV/RGB [0..4095] (bit depth 12)"]
pub const AOM_CR_FULL_RANGE: aom_color_range = 1;
#[doc = "List of supported color range"]
pub type aom_color_range = ::std::os::raw::c_uint;
#[doc = "List of supported color range"]
pub use self::aom_color_range as aom_color_range_t;
#[doc = "Unknown"]
pub const AOM_CSP_UNKNOWN: aom_chroma_sample_position = 0;
#[doc = "Horizontally co-located with luma(0, 0)*/\n/**< sample, between two vertical samples"]
pub const AOM_CSP_VERTICAL: aom_chroma_sample_position = 1;
#[doc = "Co-located with luma(0, 0) sample"]
pub const AOM_CSP_COLOCATED: aom_chroma_sample_position = 2;
#[doc = "Reserved value"]
pub const AOM_CSP_RESERVED: aom_chroma_sample_position = 3;
#[doc = "List of chroma sample positions"]
pub type aom_chroma_sample_position = ::std::os::raw::c_uint;
#[doc = "List of chroma sample positions"]
pub use self::aom_chroma_sample_position as aom_chroma_sample_position_t;
#[doc = "Adds metadata if it's not keyframe"]
pub const AOM_MIF_NON_KEY_FRAME: aom_metadata_insert_flags = 0;
#[doc = "Adds metadata only if it's a keyframe"]
pub const AOM_MIF_KEY_FRAME: aom_metadata_insert_flags = 1;
#[doc = "Adds metadata to any type of frame"]
pub const AOM_MIF_ANY_FRAME: aom_metadata_insert_flags = 2;
#[doc = "List of insert flags for Metadata\n\n These flags control how the library treats metadata during encode.\n\n While encoding, when metadata is added to an aom_image via\n aom_img_add_metadata(), the flag passed along with the metadata will\n determine where the metadata OBU will be placed in the encoded OBU stream.\n Metadata will be emitted into the output stream within the next temporal unit\n if it satisfies the specified insertion flag.\n\n During decoding, when the library encounters a metadata OBU, it is always\n flagged as AOM_MIF_ANY_FRAME and emitted with the next output aom_image."]
pub type aom_metadata_insert_flags = ::std::os::raw::c_uint;
#[doc = "List of insert flags for Metadata\n\n These flags control how the library treats metadata during encode.\n\n While encoding, when metadata is added to an aom_image via\n aom_img_add_metadata(), the flag passed along with the metadata will\n determine where the metadata OBU will be placed in the encoded OBU stream.\n Metadata will be emitted into the output stream within the next temporal unit\n if it satisfies the specified insertion flag.\n\n During decoding, when the library encounters a metadata OBU, it is always\n flagged as AOM_MIF_ANY_FRAME and emitted with the next output aom_image."]
pub use self::aom_metadata_insert_flags as aom_metadata_insert_flags_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_metadata_array {
    _unused: [u8; 0],
}
#[doc = "Array of aom_metadata structs for an image."]
pub type aom_metadata_array_t = aom_metadata_array;
#[doc = "Metadata payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_metadata {
    #[doc = "Metadata type"]
    pub type_: u32,
    #[doc = "Metadata payload data"]
    pub payload: *mut u8,
    #[doc = "Metadata payload size"]
    pub sz: usize,
    #[doc = "Metadata insertion flag"]
    pub insert_flag: aom_metadata_insert_flags_t,
}
#[doc = "Metadata payload."]
pub type aom_metadata_t = aom_metadata;
#[doc = "Image Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_image {
    #[doc = "Image Format"]
    pub fmt: aom_img_fmt_t,
    #[doc = "CICP Color Primaries"]
    pub cp: aom_color_primaries_t,
    #[doc = "CICP Transfer Characteristics"]
    pub tc: aom_transfer_characteristics_t,
    #[doc = "CICP Matrix Coefficients"]
    pub mc: aom_matrix_coefficients_t,
    #[doc = "Whether image is monochrome"]
    pub monochrome: ::std::os::raw::c_int,
    #[doc = "chroma sample position"]
    pub csp: aom_chroma_sample_position_t,
    #[doc = "Color Range"]
    pub range: aom_color_range_t,
    #[doc = "Stored image width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "Stored image height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "Stored image bit-depth"]
    pub bit_depth: ::std::os::raw::c_uint,
    #[doc = "Displayed image width"]
    pub d_w: ::std::os::raw::c_uint,
    #[doc = "Displayed image height"]
    pub d_h: ::std::os::raw::c_uint,
    #[doc = "Intended rendering image width"]
    pub r_w: ::std::os::raw::c_uint,
    #[doc = "Intended rendering image height"]
    pub r_h: ::std::os::raw::c_uint,
    #[doc = "subsampling order, X"]
    pub x_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "subsampling order, Y"]
    pub y_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "pointer to the top left pixel for each plane"]
    pub planes: [*mut ::std::os::raw::c_uchar; 3usize],
    #[doc = "stride between rows for each plane"]
    pub stride: [::std::os::raw::c_int; 3usize],
    #[doc = "data size"]
    pub sz: usize,
    #[doc = "bits per sample (for packed formats)"]
    pub bps: ::std::os::raw::c_int,
    #[doc = "Temporal layer Id of image"]
    pub temporal_id: ::std::os::raw::c_int,
    #[doc = "Spatial layer Id of image"]
    pub spatial_id: ::std::os::raw::c_int,
    #[doc = "The following member may be set by the application to associate\n data with this image."]
    pub user_priv: *mut ::std::os::raw::c_void,
    #[doc = "private"]
    pub img_data: *mut ::std::os::raw::c_uchar,
    #[doc = "private"]
    pub img_data_owner: ::std::os::raw::c_int,
    #[doc = "private"]
    pub self_allocd: ::std::os::raw::c_int,
    #[doc = "Metadata payloads associated with the image."]
    pub metadata: *mut aom_metadata_array_t,
    #[doc = "Frame buffer data associated with the image."]
    pub fb_priv: *mut ::std::os::raw::c_void,
}
#[doc = "Image Descriptor"]
pub type aom_image_t = aom_image;
extern "C" {
    #[doc = "Open a descriptor, allocating storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for the image is allocated on the heap.\n\n \\param[in]    img       Pointer to storage for descriptor. If this parameter\n                         is NULL, the storage for the descriptor will be\n                         allocated on the heap.\n \\param[in]    fmt       Format for the image\n \\param[in]    d_w       Width of the image\n \\param[in]    d_h       Height of the image\n \\param[in]    align     Alignment, in bytes, of the image buffer and\n                         each row in the image (stride).\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn aom_img_alloc(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "Open a descriptor, using existing storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for the image has been allocated elsewhere, and a descriptor is\n desired to \"wrap\" that storage.\n\n \\param[in]    img       Pointer to storage for descriptor. If this parameter\n                         is NULL, the storage for the descriptor will be\n                         allocated on the heap.\n \\param[in]    fmt       Format for the image\n \\param[in]    d_w       Width of the image\n \\param[in]    d_h       Height of the image\n \\param[in]    align     Alignment, in bytes, of each row in the image\n                         (stride).\n \\param[in]    img_data  Storage to use for the image\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn aom_img_wrap(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        img_data: *mut ::std::os::raw::c_uchar,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "Open a descriptor, allocating storage for the underlying image with a\n border\n\n Returns a descriptor for storing an image of the given format and its\n borders. The storage for the image is allocated on the heap.\n\n \\param[in]    img        Pointer to storage for descriptor. If this parameter\n                          is NULL, the storage for the descriptor will be\n                          allocated on the heap.\n \\param[in]    fmt        Format for the image\n \\param[in]    d_w        Width of the image\n \\param[in]    d_h        Height of the image\n \\param[in]    align      Alignment, in bytes, of the image buffer and\n                          each row in the image (stride).\n \\param[in]    size_align Alignment, in pixels, of the image width and height.\n \\param[in]    border     A border that is padded on four sides of the image.\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn aom_img_alloc_with_border(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        size_align: ::std::os::raw::c_uint,
        border: ::std::os::raw::c_uint,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "Set the rectangle identifying the displayed portion of the image\n\n Updates the displayed rectangle (aka viewport) on the image surface to\n match the specified coordinates and size. Specifically, sets img->d_w,\n img->d_h, and elements of the img->planes[] array.\n\n \\param[in]    img       Image descriptor\n \\param[in]    x         leftmost column\n \\param[in]    y         topmost row\n \\param[in]    w         width\n \\param[in]    h         height\n \\param[in]    border    A border that is padded on four sides of the image.\n\n \\return 0 if the requested rectangle is valid, nonzero (-1) otherwise."]
    pub fn aom_img_set_rect(
        img: *mut aom_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        border: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Flip the image vertically (top for bottom)\n\n Adjusts the image descriptor's pointers and strides to make the image\n be referenced upside-down.\n\n \\param[in]    img       Image descriptor"]
    pub fn aom_img_flip(img: *mut aom_image_t);
}
extern "C" {
    #[doc = "Close an image descriptor\n\n Frees all allocated storage associated with an image descriptor.\n\n \\param[in]    img       Image descriptor"]
    pub fn aom_img_free(img: *mut aom_image_t);
}
extern "C" {
    #[doc = "Get the width of a plane\n\n Get the width of a plane of an image\n\n \\param[in]    img       Image descriptor\n \\param[in]    plane     Plane index"]
    pub fn aom_img_plane_width(
        img: *const aom_image_t,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the height of a plane\n\n Get the height of a plane of an image\n\n \\param[in]    img       Image descriptor\n \\param[in]    plane     Plane index"]
    pub fn aom_img_plane_height(
        img: *const aom_image_t,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add metadata to image.\n\n Adds metadata to aom_image_t.\n Function makes a copy of the provided data parameter.\n Metadata insertion point is controlled by insert_flag.\n\n \\param[in]    img          Image descriptor\n \\param[in]    type         Metadata type\n \\param[in]    data         Metadata contents\n \\param[in]    sz           Metadata contents size\n \\param[in]    insert_flag  Metadata insert flag\n\n \\return Returns 0 on success. If img or data is NULL, sz is 0, or memory\n allocation fails, it returns -1."]
    pub fn aom_img_add_metadata(
        img: *mut aom_image_t,
        type_: u32,
        data: *const u8,
        sz: usize,
        insert_flag: aom_metadata_insert_flags_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return a metadata payload stored within the image metadata array.\n\n Gets the metadata (aom_metadata_t) at the indicated index in the image\n metadata array.\n\n \\param[in] img          Pointer to image descriptor to get metadata from\n \\param[in] index        Metadata index to get from metadata array\n\n \\return Returns a const pointer to the selected metadata, if img and/or index\n is invalid, it returns NULL."]
    pub fn aom_img_get_metadata(img: *const aom_image_t, index: usize) -> *const aom_metadata_t;
}
extern "C" {
    #[doc = "Return the number of metadata blocks within the image.\n\n Gets the number of metadata blocks contained within the provided image\n metadata array.\n\n \\param[in] img          Pointer to image descriptor to get metadata number\n from.\n\n \\return Returns the size of the metadata array. If img or metadata is NULL,\n it returns 0."]
    pub fn aom_img_num_metadata(img: *const aom_image_t) -> usize;
}
extern "C" {
    #[doc = "Remove metadata from image.\n\n Removes all metadata in image metadata list and sets metadata list pointer\n to NULL.\n\n \\param[in]    img       Image descriptor"]
    pub fn aom_img_remove_metadata(img: *mut aom_image_t);
}
extern "C" {
    #[doc = "Allocate memory for aom_metadata struct.\n\n Allocates storage for the metadata payload, sets its type and copies the\n payload data into the aom_metadata struct. A metadata payload buffer of size\n sz is allocated and sz bytes are copied from data into the payload buffer.\n\n \\param[in]    type         Metadata type\n \\param[in]    data         Metadata data pointer\n \\param[in]    sz           Metadata size\n \\param[in]    insert_flag  Metadata insert flag\n\n \\return Returns the newly allocated aom_metadata struct. If data is NULL,\n sz is 0, or memory allocation fails, it returns NULL."]
    pub fn aom_img_metadata_alloc(
        type_: u32,
        data: *const u8,
        sz: usize,
        insert_flag: aom_metadata_insert_flags_t,
    ) -> *mut aom_metadata_t;
}
extern "C" {
    #[doc = "Free metadata struct.\n\n Free metadata struct and its buffer.\n\n \\param[in]    metadata       Metadata struct pointer"]
    pub fn aom_img_metadata_free(metadata: *mut aom_metadata_t);
}
#[doc = "Operation completed without error"]
pub const AOM_CODEC_OK: aom_codec_err_t = 0;
#[doc = "Unspecified error"]
pub const AOM_CODEC_ERROR: aom_codec_err_t = 1;
#[doc = "Memory operation failed"]
pub const AOM_CODEC_MEM_ERROR: aom_codec_err_t = 2;
#[doc = "ABI version mismatch"]
pub const AOM_CODEC_ABI_MISMATCH: aom_codec_err_t = 3;
#[doc = "Algorithm does not have required capability"]
pub const AOM_CODEC_INCAPABLE: aom_codec_err_t = 4;
#[doc = "The given bitstream is not supported.\n\n The bitstream was unable to be parsed at the highest level. The decoder\n is unable to proceed. This error \\ref SHOULD be treated as fatal to the\n stream."]
pub const AOM_CODEC_UNSUP_BITSTREAM: aom_codec_err_t = 5;
#[doc = "Encoded bitstream uses an unsupported feature\n\n The decoder does not implement a feature required by the encoder. This\n return code should only be used for features that prevent future\n pictures from being properly decoded. This error \\ref MAY be treated as\n fatal to the stream or \\ref MAY be treated as fatal to the current GOP."]
pub const AOM_CODEC_UNSUP_FEATURE: aom_codec_err_t = 6;
#[doc = "The coded data for this stream is corrupt or incomplete\n\n There was a problem decoding the current frame.  This return code\n should only be used for failures that prevent future pictures from\n being properly decoded. This error \\ref MAY be treated as fatal to the\n stream or \\ref MAY be treated as fatal to the current GOP. If decoding\n is continued for the current GOP, artifacts may be present."]
pub const AOM_CODEC_CORRUPT_FRAME: aom_codec_err_t = 7;
#[doc = "An application-supplied parameter is not valid.\n"]
pub const AOM_CODEC_INVALID_PARAM: aom_codec_err_t = 8;
#[doc = "An iterator reached the end of list.\n"]
pub const AOM_CODEC_LIST_END: aom_codec_err_t = 9;
#[doc = "Algorithm return codes"]
pub type aom_codec_err_t = ::std::os::raw::c_uint;
#[doc = "Codec capabilities bitfield\n\n  Each codec advertises the capabilities it supports as part of its\n  ::aom_codec_iface_t interface structure. Capabilities are extra interfaces\n  or functionality, and are not required to be supported.\n\n  The available flags are specified by AOM_CODEC_CAP_* defines."]
pub type aom_codec_caps_t = ::std::os::raw::c_long;
#[doc = "Initialization-time Feature Enabling\n\n  Certain codec features must be known at initialization time, to allow for\n  proper memory allocation.\n\n  The available flags are specified by AOM_CODEC_USE_* defines."]
pub type aom_codec_flags_t = ::std::os::raw::c_long;
#[doc = "Time Stamp Type\n\n An integer, which when multiplied by the stream's time base, provides\n the absolute time of a sample."]
pub type aom_codec_pts_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_iface {
    _unused: [u8; 0],
}
#[doc = "Codec interface structure.\n\n Contains function pointers and other data private to the codec\n implementation. This structure is opaque to the application. Common\n functions used with this structure:\n   - aom_codec_iface_name(aom_codec_iface_t *iface): get the\n     name of the codec\n   - aom_codec_get_caps(aom_codec_iface_t *iface): returns\n     the capabilities of the codec\n   - aom_codec_enc_config_default: generate the default config for\n     initializing the encoder (see documentation in aom_encoder.h)\n   - aom_codec_dec_init, aom_codec_enc_init: initialize the codec context\n     structure (see documentation on aom_codec_ctx).\n\n To get access to the AV1 encoder and decoder, use aom_codec_av1_cx() and\n  aom_codec_av1_dx()."]
pub type aom_codec_iface_t = aom_codec_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_priv {
    _unused: [u8; 0],
}
#[doc = "Codec private data structure.\n\n Contains data private to the codec implementation. This structure is opaque\n to the application."]
pub type aom_codec_priv_t = aom_codec_priv;
#[doc = "Compressed Frame Flags\n\n This type represents a bitfield containing information about a compressed\n frame that may be useful to an application. The most significant 16 bits\n can be used by an algorithm to provide additional detail, for example to\n support frame types that are codec specific (MPEG-1 D-frames for example)"]
pub type aom_codec_frame_flags_t = u32;
#[doc = "Iterator\n\n Opaque storage used for iterating over lists."]
pub type aom_codec_iter_t = *const ::std::os::raw::c_void;
#[doc = "Codec context structure\n\n All codecs \\ref MUST support this context structure fully. In general,\n this data should be considered private to the codec algorithm, and\n not be manipulated or examined by the calling application. Applications\n may reference the 'name' member to get a printable description of the\n algorithm."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aom_codec_ctx {
    #[doc = "Printable interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "Interface pointers"]
    pub iface: *const aom_codec_iface,
    #[doc = "Last returned error"]
    pub err: aom_codec_err_t,
    #[doc = "Detailed info, if available"]
    pub err_detail: *const ::std::os::raw::c_char,
    #[doc = "Flags passed at init time"]
    pub init_flags: aom_codec_flags_t,
    #[doc = "Configuration pointer aliasing union"]
    pub config: aom_codec_ctx__bindgen_ty_1,
    #[doc = "Algorithm private storage"]
    pub priv_: *mut aom_codec_priv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aom_codec_ctx__bindgen_ty_1 {
    pub dec: *const aom_codec_dec_cfg,
    pub enc: *const aom_codec_enc_cfg,
    pub raw: *const ::std::os::raw::c_void,
}
#[doc = "Codec context structure\n\n All codecs \\ref MUST support this context structure fully. In general,\n this data should be considered private to the codec algorithm, and\n not be manipulated or examined by the calling application. Applications\n may reference the 'name' member to get a printable description of the\n algorithm."]
pub type aom_codec_ctx_t = aom_codec_ctx;
#[doc = " 8 bits"]
pub const AOM_BITS_8: aom_bit_depth = 8;
#[doc = "10 bits"]
pub const AOM_BITS_10: aom_bit_depth = 10;
#[doc = "12 bits"]
pub const AOM_BITS_12: aom_bit_depth = 12;
#[doc = "Bit depth for codec\n *\n This enumeration determines the bit depth of the codec."]
pub type aom_bit_depth = ::std::os::raw::c_uint;
#[doc = "Bit depth for codec\n *\n This enumeration determines the bit depth of the codec."]
pub use self::aom_bit_depth as aom_bit_depth_t;
#[doc = "Always use 64x64 superblocks."]
pub const AOM_SUPERBLOCK_SIZE_64X64: aom_superblock_size = 0;
#[doc = "Always use 128x128 superblocks."]
pub const AOM_SUPERBLOCK_SIZE_128X128: aom_superblock_size = 1;
#[doc = "Select superblock size dynamically."]
pub const AOM_SUPERBLOCK_SIZE_DYNAMIC: aom_superblock_size = 2;
#[doc = "Superblock size selection.\n\n Defines the superblock size used for encoding. The superblock size can\n either be fixed at 64x64 or 128x128 pixels, or it can be dynamically\n selected by the encoder for each frame."]
pub type aom_superblock_size = ::std::os::raw::c_uint;
#[doc = "Superblock size selection.\n\n Defines the superblock size used for encoding. The superblock size can\n either be fixed at 64x64 or 128x128 pixels, or it can be dynamically\n selected by the encoder for each frame."]
pub use self::aom_superblock_size as aom_superblock_size_t;
extern "C" {
    #[doc = "Return the version information (as an integer)\n\n Returns a packed encoding of the library version number. This will only\n include the major.minor.patch component of the version number. Note that this\n encoded value should be accessed through the macros provided, as the encoding\n may change in the future.\n"]
    pub fn aom_codec_version() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the version information (as a string)\n\n Returns a printable string containing the full library version number. This\n may contain additional text following the three digit version number, as to\n indicate release candidates, pre-release versions, etc.\n"]
    pub fn aom_codec_version_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return the version information (as a string)\n\n Returns a printable \"extra string\". This is the component of the string\n returned by aom_codec_version_str() following the three digit version number.\n"]
    pub fn aom_codec_version_extra_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return the build configuration\n\n Returns a printable string containing an encoded version of the build\n configuration. This may be useful to aom support.\n"]
    pub fn aom_codec_build_config() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return the name for a given interface\n\n Returns a human readable string for name of the given codec interface.\n\n \\param[in]    iface     Interface pointer\n"]
    pub fn aom_codec_iface_name(iface: *const aom_codec_iface) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert error number to printable string\n\n Returns a human readable string for the last error returned by the\n algorithm. The returned error will be one line and will not contain\n any newline characters.\n\n\n \\param[in]    err     Error number.\n"]
    pub fn aom_codec_err_to_string(err: aom_codec_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieve error synopsis for codec context\n\n Returns a human readable string for the last error returned by the\n algorithm. The returned error will be one line and will not contain\n any newline characters.\n\n\n \\param[in]    ctx     Pointer to this instance's context.\n"]
    pub fn aom_codec_error(ctx: *const aom_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieve detailed error information for codec context\n\n Returns a human readable string providing detailed information about\n the last error. The returned string is only valid until the next\n aom_codec_* function call (except aom_codec_error and\n aom_codec_error_detail) on the codec context.\n\n \\param[in]    ctx     Pointer to this instance's context.\n\n \\retval NULL\n     No detailed information is available."]
    pub fn aom_codec_error_detail(ctx: *const aom_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Destroy a codec instance\n\n Destroys a codec context, freeing any associated memory buffers.\n\n \\param[in] ctx   Pointer to this instance's context\n\n \\retval #AOM_CODEC_OK\n     The codec instance has been destroyed.\n \\retval #AOM_CODEC_INVALID_PARAM\n     ctx is a null pointer.\n \\retval #AOM_CODEC_ERROR\n     Codec context not initialized."]
    pub fn aom_codec_destroy(ctx: *mut aom_codec_ctx_t) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Get the capabilities of an algorithm.\n\n Retrieves the capabilities bitfield from the algorithm's interface.\n\n \\param[in] iface   Pointer to the algorithm interface\n"]
    pub fn aom_codec_get_caps(iface: *const aom_codec_iface) -> aom_codec_caps_t;
}
extern "C" {
    #[doc = "\\name Codec Control\n\n The aom_codec_control function exchanges algorithm specific data with the\n codec instance. Additionally, the macro AOM_CODEC_CONTROL_TYPECHECKED is\n provided, which will type-check the parameter against the control ID before\n calling aom_codec_control - note that this macro requires the control ID\n to be directly encoded in it, e.g.,\n AOM_CODEC_CONTROL_TYPECHECKED(&ctx, AOME_SET_CPUUSED, 8).\n\n The codec control IDs can be found in aom.h, aomcx.h, and aomdx.h\n (defined as aom_com_control_id, aome_enc_control_id, and aom_dec_control_id).\n @{\n/\n/*!Algorithm Control\n\n aom_codec_control takes a context, a control ID, and a third parameter\n (with varying type). If the context is non-null and an error occurs,\n ctx->err will be set to the same value as the return value.\n\n \\param[in]     ctx              Pointer to this instance's context\n \\param[in]     ctrl_id          Algorithm specific control identifier.\n                                 Must be nonzero.\n\n \\retval #AOM_CODEC_OK\n     The control request was processed.\n \\retval #AOM_CODEC_ERROR\n     The control request was not processed.\n \\retval #AOM_CODEC_INVALID_PARAM\n     The control ID was zero, or the data was not valid."]
    pub fn aom_codec_control(
        ctx: *mut aom_codec_ctx_t,
        ctrl_id: ::std::os::raw::c_int,
        ...
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Key & Value API\n\n aom_codec_set_option() takes a context, a key (option name) and a value. If\n the context is non-null and an error occurs, ctx->err will be set to the same\n value as the return value.\n\n \\param[in]     ctx              Pointer to this instance's context\n \\param[in]     name             The name of the option (key)\n \\param[in]     value            The value of the option\n\n \\retval #AOM_CODEC_OK\n     The value of the option was set.\n \\retval #AOM_CODEC_INVALID_PARAM\n     The data was not valid.\n \\retval #AOM_CODEC_ERROR\n     The option was not successfully set."]
    pub fn aom_codec_set_option(
        ctx: *mut aom_codec_ctx_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> aom_codec_err_t;
}
pub const OBU_SEQUENCE_HEADER: OBU_TYPE = 1;
pub const OBU_TEMPORAL_DELIMITER: OBU_TYPE = 2;
pub const OBU_FRAME_HEADER: OBU_TYPE = 3;
pub const OBU_TILE_GROUP: OBU_TYPE = 4;
pub const OBU_METADATA: OBU_TYPE = 5;
pub const OBU_FRAME: OBU_TYPE = 6;
pub const OBU_REDUNDANT_FRAME_HEADER: OBU_TYPE = 7;
pub const OBU_TILE_LIST: OBU_TYPE = 8;
pub const OBU_PADDING: OBU_TYPE = 15;
#[doc = "OBU types."]
pub type OBU_TYPE = ::std::os::raw::c_uchar;
pub const OBU_METADATA_TYPE_AOM_RESERVED_0: OBU_METADATA_TYPE = 0;
pub const OBU_METADATA_TYPE_HDR_CLL: OBU_METADATA_TYPE = 1;
pub const OBU_METADATA_TYPE_HDR_MDCV: OBU_METADATA_TYPE = 2;
pub const OBU_METADATA_TYPE_SCALABILITY: OBU_METADATA_TYPE = 3;
pub const OBU_METADATA_TYPE_ITUT_T35: OBU_METADATA_TYPE = 4;
pub const OBU_METADATA_TYPE_TIMECODE: OBU_METADATA_TYPE = 5;
#[doc = "OBU metadata types."]
pub type OBU_METADATA_TYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Returns string representation of OBU_TYPE.\n\n \\param[in]     type            The OBU_TYPE to convert to string."]
    pub fn aom_obu_type_to_string(type_: OBU_TYPE) -> *const ::std::os::raw::c_char;
}
#[doc = "Codec control function to get a pointer to a reference frame\n\n av1_ref_frame_t* parameter"]
pub const AV1_GET_REFERENCE: aom_com_control_id = 230;
#[doc = "Codec control function to write a frame into a reference buffer\n\n av1_ref_frame_t* parameter"]
pub const AV1_SET_REFERENCE: aom_com_control_id = 231;
#[doc = "Codec control function to get a copy of reference frame from the\n decoder\n\n av1_ref_frame_t* parameter"]
pub const AV1_COPY_REFERENCE: aom_com_control_id = 232;
#[doc = "Codec control function to get a pointer to the new frame\n\n aom_image_t* parameter"]
pub const AV1_GET_NEW_FRAME_IMAGE: aom_com_control_id = 233;
#[doc = "Codec control function to copy the new frame to an external buffer\n\n aom_image_t* parameter"]
pub const AV1_COPY_NEW_FRAME_IMAGE: aom_com_control_id = 234;
#[doc = "Start point of control IDs for aom_dec_control_id.\n Any new common control IDs should be added above."]
pub const AOM_DECODER_CTRL_ID_START: aom_com_control_id = 256;
#[doc = "Control functions\n\n The set of macros define the control functions of AOM interface\n The range for common control IDs is 230-255(max)."]
pub type aom_com_control_id = ::std::os::raw::c_uint;
#[doc = "AV1 specific reference frame data struct\n\n Define the data struct to access av1 reference frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct av1_ref_frame {
    #[doc = "frame index to get (input)"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "Directly use external ref buffer(decoder only)"]
    pub use_external_ref: ::std::os::raw::c_int,
    #[doc = "img structure to populate (output)"]
    pub img: aom_image_t,
}
#[doc = "AV1 specific reference frame data struct\n\n Define the data struct to access av1 reference frames."]
pub type av1_ref_frame_t = av1_ref_frame;
pub type aom_codec_control_type_AV1_GET_REFERENCE = *mut av1_ref_frame_t;
pub type aom_codec_control_type_AV1_SET_REFERENCE = *mut av1_ref_frame_t;
pub type aom_codec_control_type_AV1_COPY_REFERENCE = *mut av1_ref_frame_t;
pub type aom_codec_control_type_AV1_GET_NEW_FRAME_IMAGE = *mut aom_image_t;
pub type aom_codec_control_type_AV1_COPY_NEW_FRAME_IMAGE = *mut aom_image_t;
#[doc = "Abstract external partition model handler"]
pub type aom_ext_part_model_t = *mut ::std::os::raw::c_void;
pub const AOM_EXT_PART_WHOLE_TREE: aom_ext_part_decision_mode = 0;
pub const AOM_EXT_PART_RECURSIVE: aom_ext_part_decision_mode = 1;
#[doc = "Decision mode of the external partition model.\n AOM_EXT_PART_WHOLE_TREE: the external partition model should provide the\n whole partition tree for the superblock.\n\n AOM_EXT_PART_RECURSIVE: the external partition model provides the partition\n decision of the current block only. The decision process starts from\n the superblock size, down to the smallest block size (4x4) recursively."]
pub type aom_ext_part_decision_mode = ::std::os::raw::c_uint;
#[doc = "Decision mode of the external partition model.\n AOM_EXT_PART_WHOLE_TREE: the external partition model should provide the\n whole partition tree for the superblock.\n\n AOM_EXT_PART_RECURSIVE: the external partition model provides the partition\n decision of the current block only. The decision process starts from\n the superblock size, down to the smallest block size (4x4) recursively."]
pub use self::aom_ext_part_decision_mode as aom_ext_part_decision_mode_t;
#[doc = "Config information sent to the external partition model.\n\n For example, the maximum superblock size determined by the sequence header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_ext_part_config {
    #[doc = "super block size (either 64x64 or 128x128)"]
    pub superblock_size: ::std::os::raw::c_int,
}
#[doc = "Config information sent to the external partition model.\n\n For example, the maximum superblock size determined by the sequence header."]
pub type aom_ext_part_config_t = aom_ext_part_config;
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected before NONE partition.\n Features \"f\" are used to determine:\n partition_none_allowed, partition_horz_allowed, partition_vert_allowed,\n do_rectangular_split, do_square_split\n Features \"f_part2\" are used to determine:\n prune_horz, prune_vert."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features_before_none {
    #[doc = " features to determine whether skip partition none and do split directly"]
    pub f: [f32; 17usize],
    #[doc = " features to determine whether to prune rectangular partition"]
    pub f_part2: [f32; 25usize],
}
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected before NONE partition.\n Features \"f\" are used to determine:\n partition_none_allowed, partition_horz_allowed, partition_vert_allowed,\n do_rectangular_split, do_square_split\n Features \"f_part2\" are used to determine:\n prune_horz, prune_vert."]
pub type aom_partition_features_before_none_t = aom_partition_features_before_none;
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after NONE partition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features_none {
    #[doc = " features to prune split and rectangular partition"]
    pub f: [f32; 4usize],
    #[doc = " features to determine termination of partition"]
    pub f_terminate: [f32; 28usize],
}
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after NONE partition."]
pub type aom_partition_features_none_t = aom_partition_features_none;
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after SPLIT partition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features_split {
    #[doc = " features to determine termination of  partition"]
    pub f_terminate: [f32; 31usize],
    #[doc = " features to determine pruning rect partition"]
    pub f_prune_rect: [f32; 9usize],
}
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after SPLIT partition."]
pub type aom_partition_features_split_t = aom_partition_features_split;
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after RECTANGULAR partition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features_rect {
    #[doc = " features to determine pruning AB partition"]
    pub f: [f32; 10usize],
}
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after RECTANGULAR partition."]
pub type aom_partition_features_rect_t = aom_partition_features_rect;
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after AB partition: HORZ_A, HORZ_B, VERT_A,\n VERT_B."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features_ab {
    #[doc = " features to determine pruning 4-way partition"]
    pub f: [f32; 18usize],
}
#[doc = "Features pass to the external model to make partition decisions.\n Specifically, features collected after AB partition: HORZ_A, HORZ_B, VERT_A,\n VERT_B."]
pub type aom_partition_features_ab_t = aom_partition_features_ab;
pub const AOM_EXT_PART_FEATURE_BEFORE_NONE: AOM_EXT_PART_FEATURE_ID = 0;
pub const AOM_EXT_PART_FEATURE_BEFORE_NONE_PART2: AOM_EXT_PART_FEATURE_ID = 1;
pub const AOM_EXT_PART_FEATURE_AFTER_NONE: AOM_EXT_PART_FEATURE_ID = 2;
pub const AOM_EXT_PART_FEATURE_AFTER_NONE_PART2: AOM_EXT_PART_FEATURE_ID = 3;
pub const AOM_EXT_PART_FEATURE_AFTER_SPLIT: AOM_EXT_PART_FEATURE_ID = 4;
pub const AOM_EXT_PART_FEATURE_AFTER_SPLIT_PART2: AOM_EXT_PART_FEATURE_ID = 5;
pub const AOM_EXT_PART_FEATURE_AFTER_RECT: AOM_EXT_PART_FEATURE_ID = 6;
pub const AOM_EXT_PART_FEATURE_AFTER_AB: AOM_EXT_PART_FEATURE_ID = 7;
#[doc = "Feature id to tell the external model the current stage in partition\n pruning and what features to use to make decisions accordingly."]
pub type AOM_EXT_PART_FEATURE_ID = ::std::os::raw::c_uint;
#[doc = "Features collected from the tpl process.\n\n The tpl process collects information that help measure the inter-frame\n dependency.\n The tpl process is computed in the unit of tpl_bsize_1d (16x16).\n Therefore, the max number of units inside a superblock is\n 128x128 / (16x16) = 64. Change it if the tpl process changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_sb_tpl_features {
    #[doc = "If tpl stats are available"]
    pub available: ::std::os::raw::c_int,
    #[doc = "The block length of tpl process"]
    pub tpl_unit_length: ::std::os::raw::c_int,
    #[doc = "The number of units inside the current superblock"]
    pub num_units: ::std::os::raw::c_int,
    #[doc = "The intra cost of each unit"]
    pub intra_cost: [i64; 64usize],
    #[doc = "The inter cost of each unit"]
    pub inter_cost: [i64; 64usize],
    #[doc = "The motion compensated dependency cost"]
    pub mc_dep_cost: [i64; 64usize],
}
#[doc = "Features collected from the tpl process.\n\n The tpl process collects information that help measure the inter-frame\n dependency.\n The tpl process is computed in the unit of tpl_bsize_1d (16x16).\n Therefore, the max number of units inside a superblock is\n 128x128 / (16x16) = 64. Change it if the tpl process changes."]
pub type aom_sb_tpl_features_t = aom_sb_tpl_features;
#[doc = "Features collected from the simple motion process.\n\n The simple motion process collects information by applying motion compensated\n prediction on each block.\n The block size is 16x16, which could be changed. If it is changed, update\n comments and the array size here."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_sb_simple_motion_features {
    #[doc = "The block length of the simple motion process"]
    pub unit_length: ::std::os::raw::c_int,
    #[doc = "The number of units inside the current superblock"]
    pub num_units: ::std::os::raw::c_int,
    #[doc = "Sum of squared error of each unit"]
    pub block_sse: [::std::os::raw::c_int; 64usize],
    #[doc = "Variance of each unit"]
    pub block_var: [::std::os::raw::c_int; 64usize],
}
#[doc = "Features collected from the simple motion process.\n\n The simple motion process collects information by applying motion compensated\n prediction on each block.\n The block size is 16x16, which could be changed. If it is changed, update\n comments and the array size here."]
pub type aom_sb_simple_motion_features_t = aom_sb_simple_motion_features;
#[doc = "Features of each super block.\n\n Features collected for each super block before partition search."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_sb_features {
    #[doc = " Features from motion search"]
    pub motion_features: aom_sb_simple_motion_features_t,
    #[doc = " Features from tpl process"]
    pub tpl_features: aom_sb_tpl_features_t,
}
#[doc = "Features of each super block.\n\n Features collected for each super block before partition search."]
pub type aom_sb_features_t = aom_sb_features;
#[doc = "Features pass to the external model to make partition decisions.\n\n The encoder sends these features to the external model through\n \"func()\" defined in .....\n\n NOTE: new member variables may be added to this structure in the future.\n Once new features are finalized, bump the major version of libaom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_features {
    #[doc = " Feature ID to indicate active features"]
    pub id: AOM_EXT_PART_FEATURE_ID,
    #[doc = " Features collected before NONE partition"]
    pub before_part_none: aom_partition_features_before_none_t,
    #[doc = " Features collected after NONE partition"]
    pub after_part_none: aom_partition_features_none_t,
    #[doc = " Features collected after SPLIT partition"]
    pub after_part_split: aom_partition_features_split_t,
    #[doc = " Features collected after RECTANGULAR partition"]
    pub after_part_rect: aom_partition_features_rect_t,
    #[doc = " Features collected after AB partition"]
    pub after_part_ab: aom_partition_features_ab_t,
    #[doc = "Features collected for the super block"]
    pub sb_features: aom_sb_features_t,
    #[doc = "Mi_row position of the block"]
    pub mi_row: ::std::os::raw::c_int,
    #[doc = "Mi_col position of the block"]
    pub mi_col: ::std::os::raw::c_int,
    #[doc = "Frame width"]
    pub frame_width: ::std::os::raw::c_int,
    #[doc = "Frame height"]
    pub frame_height: ::std::os::raw::c_int,
    #[doc = "As \"BLOCK_SIZE\" in av1/common/enums.h"]
    pub block_size: ::std::os::raw::c_int,
    #[doc = " Valid partition types. A bitmask is used.  \"1\" represents the\n corresponding type is valid. The bitmask follows the enum order for\n PARTITION_TYPE in \"enums.h\" to represent one partition type at a bit.\n For example, 0x01 stands for only PARTITION_NONE is valid,\n 0x09 (00...001001) stands for PARTITION_NONE and PARTITION_SPLIT are valid."]
    pub valid_partition_types: ::std::os::raw::c_int,
    #[doc = "Frame update type, defined in ratectrl.h"]
    pub update_type: ::std::os::raw::c_int,
    #[doc = "Quantization index, range: [0, 255]"]
    pub qindex: ::std::os::raw::c_int,
    #[doc = "Rate-distortion multiplier"]
    pub rdmult: ::std::os::raw::c_int,
    #[doc = "The level of this frame in the hierarchical structure"]
    pub pyramid_level: ::std::os::raw::c_int,
    #[doc = "Has above neighbor block"]
    pub has_above_block: ::std::os::raw::c_int,
    #[doc = "Width of the above block, -1 if not exist"]
    pub above_block_width: ::std::os::raw::c_int,
    #[doc = "Height of the above block, -1 if not exist"]
    pub above_block_height: ::std::os::raw::c_int,
    #[doc = "Has left neighbor block"]
    pub has_left_block: ::std::os::raw::c_int,
    #[doc = "Width of the left block, -1 if not exist"]
    pub left_block_width: ::std::os::raw::c_int,
    #[doc = "Height of the left block, -1 if not exist"]
    pub left_block_height: ::std::os::raw::c_int,
    #[doc = "SSE of motion compensated residual"]
    pub block_sse: ::std::os::raw::c_uint,
    #[doc = "Variance of motion compensated residual"]
    pub block_var: ::std::os::raw::c_uint,
    #[doc = "SSE of sub blocks."]
    pub sub_block_sse: [::std::os::raw::c_uint; 4usize],
    #[doc = "Variance of sub blocks."]
    pub sub_block_var: [::std::os::raw::c_uint; 4usize],
    #[doc = "SSE of horz sub blocks"]
    pub horz_block_sse: [::std::os::raw::c_uint; 2usize],
    #[doc = "Variance of horz sub blocks"]
    pub horz_block_var: [::std::os::raw::c_uint; 2usize],
    #[doc = "SSE of vert sub blocks"]
    pub vert_block_sse: [::std::os::raw::c_uint; 2usize],
    #[doc = "Variance of vert sub blocks"]
    pub vert_block_var: [::std::os::raw::c_uint; 2usize],
    #[doc = "Intra cost, ref to \"TplDepStats\" in tpl_model.h"]
    pub tpl_intra_cost: i64,
    #[doc = "Inter cost in tpl model"]
    pub tpl_inter_cost: i64,
    #[doc = "Motion compensated dependency cost in tpl model"]
    pub tpl_mc_dep_cost: i64,
}
#[doc = "Features pass to the external model to make partition decisions.\n\n The encoder sends these features to the external model through\n \"func()\" defined in .....\n\n NOTE: new member variables may be added to this structure in the future.\n Once new features are finalized, bump the major version of libaom."]
pub type aom_partition_features_t = aom_partition_features;
#[doc = "Partition decisions received from the external model.\n\n The encoder receives partition decisions and encodes the superblock\n with the given partition type.\n The encoder receives it from \"func()\" define in ....\n\n NOTE: new member variables may be added to this structure in the future.\n Once new features are finalized, bump the major version of libaom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_decision {
    #[doc = "The flag whether it's the final decision"]
    pub is_final_decision: ::std::os::raw::c_int,
    #[doc = "The number of leaf nodes"]
    pub num_nodes: ::std::os::raw::c_int,
    #[doc = "Partition decisions"]
    pub partition_decision: [::std::os::raw::c_int; 2048usize],
    #[doc = "Partition decision for the current block"]
    pub current_decision: ::std::os::raw::c_int,
    #[doc = "Terminate further partition search"]
    pub terminate_partition_search: ::std::os::raw::c_int,
    #[doc = "Allow partition none type"]
    pub partition_none_allowed: ::std::os::raw::c_int,
    #[doc = "Allow rectangular partitions"]
    pub partition_rect_allowed: [::std::os::raw::c_int; 2usize],
    #[doc = "Try rectangular split partition"]
    pub do_rectangular_split: ::std::os::raw::c_int,
    #[doc = "Try square split partition"]
    pub do_square_split: ::std::os::raw::c_int,
    #[doc = "Prune rectangular partition"]
    pub prune_rect_part: [::std::os::raw::c_int; 2usize],
    #[doc = "Allow HORZ_A partition"]
    pub horza_partition_allowed: ::std::os::raw::c_int,
    #[doc = "Allow HORZ_B partition"]
    pub horzb_partition_allowed: ::std::os::raw::c_int,
    #[doc = "Allow VERT_A partition"]
    pub verta_partition_allowed: ::std::os::raw::c_int,
    #[doc = "Allow VERT_B partition"]
    pub vertb_partition_allowed: ::std::os::raw::c_int,
    #[doc = "Allow HORZ4 partition"]
    pub partition_horz4_allowed: ::std::os::raw::c_int,
    #[doc = "Allow VERT4 partition"]
    pub partition_vert4_allowed: ::std::os::raw::c_int,
}
#[doc = "Partition decisions received from the external model.\n\n The encoder receives partition decisions and encodes the superblock\n with the given partition type.\n The encoder receives it from \"func()\" define in ....\n\n NOTE: new member variables may be added to this structure in the future.\n Once new features are finalized, bump the major version of libaom."]
pub type aom_partition_decision_t = aom_partition_decision;
#[doc = "Encoding stats for the given partition decision.\n\n The encoding stats collected by encoding the superblock with the\n given partition types.\n The encoder sends the stats to the external model for training\n or inference through \"func()\" defined in ...."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_partition_stats {
    #[doc = "Rate cost of the block"]
    pub rate: ::std::os::raw::c_int,
    #[doc = "Distortion of the block"]
    pub dist: i64,
    #[doc = "Rate-distortion cost of the block"]
    pub rdcost: i64,
}
#[doc = "Encoding stats for the given partition decision.\n\n The encoding stats collected by encoding the superblock with the\n given partition types.\n The encoder sends the stats to the external model for training\n or inference through \"func()\" defined in ...."]
pub type aom_partition_stats_t = aom_partition_stats;
#[doc = "Status of success"]
pub const AOM_EXT_PART_OK: aom_ext_part_status = 0;
#[doc = "Status of failure"]
pub const AOM_EXT_PART_ERROR: aom_ext_part_status = 1;
#[doc = "Status used for tests"]
pub const AOM_EXT_PART_TEST: aom_ext_part_status = 2;
#[doc = "Enum for return status."]
pub type aom_ext_part_status = ::std::os::raw::c_uint;
#[doc = "Enum for return status."]
pub use self::aom_ext_part_status as aom_ext_part_status_t;
#[doc = "Callback of creating an external partition model.\n\n The callback is invoked by the encoder to create an external partition\n model.\n\n \\param[in] priv Callback's private data\n \\param[in] part_config Config information pointer for model creation\n \\param[out] ext_part_model Pointer to the model"]
pub type aom_ext_part_create_model_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        part_config: *const aom_ext_part_config_t,
        ext_part_model: *mut aom_ext_part_model_t,
    ) -> aom_ext_part_status_t,
>;
#[doc = "Callback of sending features to the external partition model.\n\n The callback is invoked by the encoder to send features to the external\n partition model.\n\n \\param[in] ext_part_model The external model\n \\param[in] part_features Pointer to the features"]
pub type aom_ext_part_send_features_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        ext_part_model: aom_ext_part_model_t,
        part_features: *const aom_partition_features_t,
    ) -> aom_ext_part_status_t,
>;
#[doc = "Callback of receiving partition decisions from the external\n partition model.\n\n The callback is invoked by the encoder to receive partition decisions from\n the external partition model.\n\n \\param[in] ext_part_model The external model\n \\param[in] ext_part_decision Pointer to the partition decisions"]
pub type aom_ext_part_get_decision_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        ext_part_model: aom_ext_part_model_t,
        ext_part_decision: *mut aom_partition_decision_t,
    ) -> aom_ext_part_status_t,
>;
#[doc = "Callback of sending stats to the external partition model.\n\n The callback is invoked by the encoder to send encoding stats to\n the external partition model.\n\n \\param[in] ext_part_model The external model\n \\param[in] ext_part_stats Pointer to the encoding stats"]
pub type aom_ext_part_send_partition_stats_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        ext_part_model: aom_ext_part_model_t,
        ext_part_stats: *const aom_partition_stats_t,
    ) -> aom_ext_part_status_t,
>;
#[doc = "Callback of deleting the external partition model.\n\n The callback is invoked by the encoder to delete the external partition\n model.\n\n \\param[in] ext_part_model The external model"]
pub type aom_ext_part_delete_model_fn_t = ::std::option::Option<
    unsafe extern "C" fn(ext_part_model: aom_ext_part_model_t) -> aom_ext_part_status_t,
>;
#[doc = "Callback function set for external partition model.\n\n Uses can enable external partition model by registering a set of\n callback functions with the flag: AV1E_SET_EXTERNAL_PARTITION_MODEL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_ext_part_funcs {
    #[doc = " Create an external partition model."]
    pub create_model: aom_ext_part_create_model_fn_t,
    #[doc = " Send features to the external partition model to make partition decisions."]
    pub send_features: aom_ext_part_send_features_fn_t,
    #[doc = " Get partition decisions from the external partition model."]
    pub get_partition_decision: aom_ext_part_get_decision_fn_t,
    #[doc = " Send stats of the current partition to the external model."]
    pub send_partition_stats: aom_ext_part_send_partition_stats_fn_t,
    #[doc = " Delete the external partition model."]
    pub delete_model: aom_ext_part_delete_model_fn_t,
    #[doc = " The decision mode of the model."]
    pub decision_mode: aom_ext_part_decision_mode_t,
    #[doc = " Private data for the external partition model."]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[doc = "Callback function set for external partition model.\n\n Uses can enable external partition model by registering a set of\n callback functions with the flag: AV1E_SET_EXTERNAL_PARTITION_MODEL"]
pub type aom_ext_part_funcs_t = aom_ext_part_funcs;
#[doc = "Generic fixed size buffer structure\n\n This structure is able to hold a reference to any fixed size buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_fixed_buf {
    #[doc = "Pointer to the data. Does NOT own the data!"]
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = "Length of the buffer, in chars"]
    pub sz: usize,
}
#[doc = "Generic fixed size buffer structure\n\n This structure is able to hold a reference to any fixed size buffer."]
pub type aom_fixed_buf_t = aom_fixed_buf;
#[doc = "Error Resilient flags\n\n These flags define which error resilient features to enable in the\n encoder. The flags are specified through the\n aom_codec_enc_cfg::g_error_resilient variable."]
pub type aom_codec_er_flags_t = u32;
#[doc = "Compressed video frame"]
pub const AOM_CODEC_CX_FRAME_PKT: aom_codec_cx_pkt_kind = 0;
#[doc = "Two-pass statistics for this frame"]
pub const AOM_CODEC_STATS_PKT: aom_codec_cx_pkt_kind = 1;
#[doc = "first pass mb statistics for this frame"]
pub const AOM_CODEC_FPMB_STATS_PKT: aom_codec_cx_pkt_kind = 2;
#[doc = "PSNR statistics for this frame"]
pub const AOM_CODEC_PSNR_PKT: aom_codec_cx_pkt_kind = 3;
#[doc = "Algorithm extensions"]
pub const AOM_CODEC_CUSTOM_PKT: aom_codec_cx_pkt_kind = 256;
#[doc = "Encoder output packet variants\n\n This enumeration lists the different kinds of data packets that can be\n returned by calls to aom_codec_get_cx_data(). Algorithms \\ref MAY\n extend this list to provide additional functionality."]
pub type aom_codec_cx_pkt_kind = ::std::os::raw::c_uint;
#[doc = "Encoder output packet\n\n This structure contains the different kinds of output data the encoder\n may produce while compressing a frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aom_codec_cx_pkt {
    #[doc = "packet variant"]
    pub kind: aom_codec_cx_pkt_kind,
    #[doc = "packet data"]
    pub data: aom_codec_cx_pkt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aom_codec_cx_pkt__bindgen_ty_1 {
    #[doc = "data for compressed frame packet"]
    pub frame: aom_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1,
    #[doc = "data for two-pass packet"]
    pub twopass_stats: aom_fixed_buf_t,
    #[doc = "first pass mb packet"]
    pub firstpass_mb_stats: aom_fixed_buf_t,
    #[doc = "data for PSNR packet"]
    pub psnr: aom_codec_cx_pkt__bindgen_ty_1_aom_psnr_pkt,
    #[doc = "data for arbitrary packets"]
    pub raw: aom_fixed_buf_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "compressed data buffer"]
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = "length of compressed data"]
    pub sz: usize,
    #[doc = "time stamp to show frame (in timebase units)"]
    pub pts: aom_codec_pts_t,
    #[doc = "duration to show frame (in timebase units)"]
    pub duration: ::std::os::raw::c_ulong,
    #[doc = "flags for this frame"]
    pub flags: aom_codec_frame_flags_t,
    #[doc = "the partition id defines the decoding order of the partitions.\n Only applicable when \"output partition\" mode is enabled. First\n partition has id 0."]
    pub partition_id: ::std::os::raw::c_int,
    #[doc = "size of the visible frame in this packet"]
    pub vis_frame_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_cx_pkt__bindgen_ty_1_aom_psnr_pkt {
    #[doc = "Number of samples, total/y/u/v"]
    pub samples: [::std::os::raw::c_uint; 4usize],
    #[doc = "sum squared error, total/y/u/v"]
    pub sse: [u64; 4usize],
    #[doc = "PSNR, total/y/u/v"]
    pub psnr: [f64; 4usize],
    #[doc = "Number of samples, total/y/u/v when\n input bit-depth < stream bit-depth."]
    pub samples_hbd: [::std::os::raw::c_uint; 4usize],
    #[doc = "sum squared error, total/y/u/v when\n input bit-depth < stream bit-depth."]
    pub sse_hbd: [u64; 4usize],
    #[doc = "PSNR, total/y/u/v when\n input bit-depth < stream bit-depth."]
    pub psnr_hbd: [f64; 4usize],
}
#[doc = "Encoder output packet\n\n This structure contains the different kinds of output data the encoder\n may produce while compressing a frame."]
pub type aom_codec_cx_pkt_t = aom_codec_cx_pkt;
#[doc = "Rational Number\n\n This structure holds a fractional value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_rational {
    #[doc = "fraction numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = "fraction denominator"]
    pub den: ::std::os::raw::c_int,
}
#[doc = "Rational Number\n\n This structure holds a fractional value."]
pub type aom_rational_t = aom_rational;
#[doc = "Single pass mode"]
pub const AOM_RC_ONE_PASS: aom_enc_pass = 0;
#[doc = "First pass of multi-pass mode"]
pub const AOM_RC_FIRST_PASS: aom_enc_pass = 1;
#[doc = "Second pass of multi-pass mode"]
pub const AOM_RC_SECOND_PASS: aom_enc_pass = 2;
#[doc = "Third pass of multi-pass mode"]
pub const AOM_RC_THIRD_PASS: aom_enc_pass = 3;
#[doc = "Final pass of two-pass mode"]
pub const AOM_RC_LAST_PASS: aom_enc_pass = 2;
#[doc = "Multi-pass Encoding Pass\n\n AOM_RC_LAST_PASS is kept for backward compatibility.\n If passes is not given and pass==2, the codec will assume passes=2.\n For new code, it is recommended to use AOM_RC_SECOND_PASS and set\n the \"passes\" member to 2 via the key & val API for two-pass encoding."]
pub type aom_enc_pass = ::std::os::raw::c_uint;
#[doc = "Variable Bit Rate (VBR) mode"]
pub const AOM_VBR: aom_rc_mode = 0;
#[doc = "Constant Bit Rate (CBR) mode"]
pub const AOM_CBR: aom_rc_mode = 1;
#[doc = "Constrained Quality (CQ)  mode"]
pub const AOM_CQ: aom_rc_mode = 2;
#[doc = "Constant Quality (Q) mode"]
pub const AOM_Q: aom_rc_mode = 3;
#[doc = "Rate control mode"]
pub type aom_rc_mode = ::std::os::raw::c_uint;
#[doc = "deprecated, implies AOM_KF_DISABLED"]
pub const AOM_KF_FIXED: aom_kf_mode = 0;
#[doc = "Encoder determines optimal placement automatically"]
pub const AOM_KF_AUTO: aom_kf_mode = 1;
#[doc = "Encoder does not place keyframes."]
pub const AOM_KF_DISABLED: aom_kf_mode = 0;
#[doc = "Keyframe placement mode.\n\n This enumeration determines whether keyframes are placed automatically by\n the encoder or whether this behavior is disabled. Older releases of this\n SDK were implemented such that AOM_KF_FIXED meant keyframes were disabled.\n This name is confusing for this behavior, so the new symbols to be used\n are AOM_KF_AUTO and AOM_KF_DISABLED."]
pub type aom_kf_mode = ::std::os::raw::c_uint;
pub const AOM_SUPERRES_NONE: aom_superres_mode = 0;
pub const AOM_SUPERRES_FIXED: aom_superres_mode = 1;
pub const AOM_SUPERRES_RANDOM: aom_superres_mode = 2;
pub const AOM_SUPERRES_QTHRESH: aom_superres_mode = 3;
pub const AOM_SUPERRES_AUTO: aom_superres_mode = 4;
#[doc = "Frame super-resolution mode."]
pub type aom_superres_mode = ::std::os::raw::c_uint;
#[doc = "Encoder Config Options\n\n This type allows to enumerate and control flags defined for encoder control\n via config file at runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg_options {
    #[doc = "Indicate init by cfg file\n 0 or 1"]
    pub init_by_cfg_file: ::std::os::raw::c_uint,
    #[doc = "Superblock size\n 0, 64 or 128"]
    pub super_block_size: ::std::os::raw::c_uint,
    #[doc = "max partition size\n 8, 16, 32, 64, 128"]
    pub max_partition_size: ::std::os::raw::c_uint,
    #[doc = "min partition size\n 8, 16, 32, 64, 128"]
    pub min_partition_size: ::std::os::raw::c_uint,
    #[doc = "disable AB Shape partition type\n"]
    pub disable_ab_partition_type: ::std::os::raw::c_uint,
    #[doc = "disable rectangular partition type\n"]
    pub disable_rect_partition_type: ::std::os::raw::c_uint,
    #[doc = "disable 1:4/4:1 partition type\n"]
    pub disable_1to4_partition_type: ::std::os::raw::c_uint,
    #[doc = "disable flip and identity transform type\n"]
    pub disable_flip_idtx: ::std::os::raw::c_uint,
    #[doc = "disable CDEF filter\n"]
    pub disable_cdef: ::std::os::raw::c_uint,
    #[doc = "disable Loop Restoration Filter\n"]
    pub disable_lr: ::std::os::raw::c_uint,
    #[doc = "disable OBMC\n"]
    pub disable_obmc: ::std::os::raw::c_uint,
    #[doc = "disable Warped Motion\n"]
    pub disable_warp_motion: ::std::os::raw::c_uint,
    #[doc = "disable global motion\n"]
    pub disable_global_motion: ::std::os::raw::c_uint,
    #[doc = "disable dist weighted compound\n"]
    pub disable_dist_wtd_comp: ::std::os::raw::c_uint,
    #[doc = "disable diff weighted compound\n"]
    pub disable_diff_wtd_comp: ::std::os::raw::c_uint,
    #[doc = "disable inter/intra compound\n"]
    pub disable_inter_intra_comp: ::std::os::raw::c_uint,
    #[doc = "disable masked compound\n"]
    pub disable_masked_comp: ::std::os::raw::c_uint,
    #[doc = "disable one sided compound\n"]
    pub disable_one_sided_comp: ::std::os::raw::c_uint,
    #[doc = "disable Palette\n"]
    pub disable_palette: ::std::os::raw::c_uint,
    #[doc = "disable Intra Block Copy\n"]
    pub disable_intrabc: ::std::os::raw::c_uint,
    #[doc = "disable chroma from luma\n"]
    pub disable_cfl: ::std::os::raw::c_uint,
    #[doc = "disable intra smooth mode\n"]
    pub disable_smooth_intra: ::std::os::raw::c_uint,
    #[doc = "disable filter intra\n"]
    pub disable_filter_intra: ::std::os::raw::c_uint,
    #[doc = "disable dual filter\n"]
    pub disable_dual_filter: ::std::os::raw::c_uint,
    #[doc = "disable intra angle delta\n"]
    pub disable_intra_angle_delta: ::std::os::raw::c_uint,
    #[doc = "disable intra edge filter\n"]
    pub disable_intra_edge_filter: ::std::os::raw::c_uint,
    #[doc = "disable 64x64 transform\n"]
    pub disable_tx_64x64: ::std::os::raw::c_uint,
    #[doc = "disable smooth inter/intra\n"]
    pub disable_smooth_inter_intra: ::std::os::raw::c_uint,
    #[doc = "disable inter/inter wedge comp\n"]
    pub disable_inter_inter_wedge: ::std::os::raw::c_uint,
    #[doc = "disable inter/intra wedge comp\n"]
    pub disable_inter_intra_wedge: ::std::os::raw::c_uint,
    #[doc = "disable paeth intra\n"]
    pub disable_paeth_intra: ::std::os::raw::c_uint,
    #[doc = "disable trellis quantization\n"]
    pub disable_trellis_quant: ::std::os::raw::c_uint,
    #[doc = "disable ref frame MV\n"]
    pub disable_ref_frame_mv: ::std::os::raw::c_uint,
    #[doc = "use reduced reference frame set\n"]
    pub reduced_reference_set: ::std::os::raw::c_uint,
    #[doc = "use reduced transform type set\n"]
    pub reduced_tx_type_set: ::std::os::raw::c_uint,
}
#[doc = "Encoder Config Options\n\n This type allows to enumerate and control flags defined for encoder control\n via config file at runtime."]
pub type cfg_options_t = cfg_options;
#[doc = "Encoded Frame Flags\n\n This type indicates a bitfield to be passed to aom_codec_encode(), defining\n per-frame boolean values. By convention, bits common to all codecs will be\n named AOM_EFLAG_*, and bits specific to an algorithm will be named\n /algo/_eflag_*. The lower order 16 bits are reserved for common use."]
pub type aom_enc_frame_flags_t = ::std::os::raw::c_long;
#[doc = "Encoder configuration structure\n\n This structure contains the encoder settings that have common representations\n across all codecs. This doesn't imply that all codecs support all features,\n however."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_enc_cfg {
    #[doc = "Algorithm specific \"usage\" value\n\n Algorithms may define multiple values for usage, which may convey the\n intent of how the application intends to use the stream. If this value\n is non-zero, consult the documentation for the codec to determine its\n meaning."]
    pub g_usage: ::std::os::raw::c_uint,
    #[doc = "Maximum number of threads to use\n\n For multi-threaded implementations, use no more than this number of\n threads. The codec may use fewer threads than allowed. The value\n 0 is equivalent to the value 1."]
    pub g_threads: ::std::os::raw::c_uint,
    #[doc = "profile of bitstream to use"]
    pub g_profile: ::std::os::raw::c_uint,
    #[doc = "Width of the frame\n\n This value identifies the presentation resolution of the frame,\n in pixels. Note that the frames passed as input to the encoder must\n have this resolution. Frames will be presented by the decoder in this\n resolution, independent of any spatial resampling the encoder may do."]
    pub g_w: ::std::os::raw::c_uint,
    #[doc = "Height of the frame\n\n This value identifies the presentation resolution of the frame,\n in pixels. Note that the frames passed as input to the encoder must\n have this resolution. Frames will be presented by the decoder in this\n resolution, independent of any spatial resampling the encoder may do."]
    pub g_h: ::std::os::raw::c_uint,
    #[doc = "Max number of frames to encode\n\n If force video mode is off (the default) and g_limit is 1, the encoder\n will encode a still picture (still_picture is set to 1 in the sequence\n header OBU). If in addition full_still_picture_hdr is 0 (the default),\n the encoder will use a reduced header (reduced_still_picture_header is\n set to 1 in the sequence header OBU) for the still picture."]
    pub g_limit: ::std::os::raw::c_uint,
    #[doc = "Forced maximum width of the frame\n\n If this value is non-zero then it is used to force the maximum frame\n width written in write_sequence_header()."]
    pub g_forced_max_frame_width: ::std::os::raw::c_uint,
    #[doc = "Forced maximum height of the frame\n\n If this value is non-zero then it is used to force the maximum frame\n height written in write_sequence_header()."]
    pub g_forced_max_frame_height: ::std::os::raw::c_uint,
    #[doc = "Bit-depth of the codec\n\n This value identifies the bit_depth of the codec,\n Only certain bit-depths are supported as identified in the\n aom_bit_depth_t enum."]
    pub g_bit_depth: aom_bit_depth_t,
    #[doc = "Bit-depth of the input frames\n\n This value identifies the bit_depth of the input frames in bits.\n Note that the frames passed as input to the encoder must have\n this bit-depth."]
    pub g_input_bit_depth: ::std::os::raw::c_uint,
    #[doc = "Stream timebase units\n\n Indicates the smallest interval of time, in seconds, used by the stream.\n For fixed frame rate material, or variable frame rate material where\n frames are timed at a multiple of a given clock (ex: video capture),\n the \\ref RECOMMENDED method is to set the timebase to the reciprocal\n of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the\n pts to correspond to the frame number, which can be handy. For\n re-encoding video from containers with absolute time timestamps, the\n \\ref RECOMMENDED method is to set the timebase to that of the parent\n container or multimedia framework (ex: 1/1000 for ms, as in FLV)."]
    pub g_timebase: aom_rational,
    #[doc = "Enable error resilient modes.\n\n The error resilient bitfield indicates to the encoder which features\n it should enable to take measures for streaming over lossy or noisy\n links."]
    pub g_error_resilient: aom_codec_er_flags_t,
    #[doc = "Multi-pass Encoding Mode\n\n This value should be set to the current phase for multi-pass encoding.\n For single pass, set to #AOM_RC_ONE_PASS."]
    pub g_pass: aom_enc_pass,
    #[doc = "Allow lagged encoding\n\n If set, this value allows the encoder to consume a number of input\n frames before producing output frames. This allows the encoder to\n base decisions for the current frame on future frames. This does\n increase the latency of the encoding pipeline, so it is not appropriate\n in all situations (ex: realtime encoding).\n\n Note that this is a maximum value -- the encoder may produce frames\n sooner than the given limit. Set this value to 0 to disable this\n feature."]
    pub g_lag_in_frames: ::std::os::raw::c_uint,
    #[doc = "Temporal resampling configuration, if supported by the codec.\n\n Temporal resampling allows the codec to \"drop\" frames as a strategy to\n meet its target data rate. This can cause temporal discontinuities in\n the encoded video, which may appear as stuttering during playback. This\n trade-off is often acceptable, but for many applications is not. It can\n be disabled in these cases.\n\n Note that not all codecs support this feature. All aom AVx codecs do.\n For other codecs, consult the documentation for that algorithm.\n\n This threshold is described as a percentage of the target data buffer.\n When the data buffer falls below this percentage of fullness, a\n dropped frame is indicated. Set the threshold to zero (0) to disable\n this feature."]
    pub rc_dropframe_thresh: ::std::os::raw::c_uint,
    #[doc = "Mode for spatial resampling, if supported by the codec.\n\n Spatial resampling allows the codec to compress a lower resolution\n version of the frame, which is then upscaled by the decoder to the\n correct presentation resolution. This increases visual quality at\n low data rates, at the expense of CPU time on the encoder/decoder."]
    pub rc_resize_mode: ::std::os::raw::c_uint,
    #[doc = "Frame resize denominator.\n\n The denominator for resize to use, assuming 8 as the numerator.\n\n Valid denominators are  8 - 16 for now."]
    pub rc_resize_denominator: ::std::os::raw::c_uint,
    #[doc = "Keyframe resize denominator.\n\n The denominator for resize to use, assuming 8 as the numerator.\n\n Valid denominators are  8 - 16 for now."]
    pub rc_resize_kf_denominator: ::std::os::raw::c_uint,
    #[doc = "Frame super-resolution scaling mode.\n\n Similar to spatial resampling, frame super-resolution integrates\n upscaling after the encode/decode process. Taking control of upscaling and\n using restoration filters should allow it to outperform normal resizing."]
    pub rc_superres_mode: aom_superres_mode,
    #[doc = "Frame super-resolution denominator.\n\n The denominator for superres to use. If fixed it will only change if the\n cumulative scale change over resizing and superres is greater than 1/2;\n this forces superres to reduce scaling.\n\n Valid denominators are 8 to 16.\n\n Used only by AOM_SUPERRES_FIXED."]
    pub rc_superres_denominator: ::std::os::raw::c_uint,
    #[doc = "Keyframe super-resolution denominator.\n\n The denominator for superres to use. If fixed it will only change if the\n cumulative scale change over resizing and superres is greater than 1/2;\n this forces superres to reduce scaling.\n\n Valid denominators are 8 - 16 for now."]
    pub rc_superres_kf_denominator: ::std::os::raw::c_uint,
    #[doc = "Frame super-resolution q threshold.\n\n The q level threshold after which superres is used.\n Valid values are 1 to 63.\n\n Used only by AOM_SUPERRES_QTHRESH"]
    pub rc_superres_qthresh: ::std::os::raw::c_uint,
    #[doc = "Keyframe super-resolution q threshold.\n\n The q level threshold after which superres is used for key frames.\n Valid values are 1 to 63.\n\n Used only by AOM_SUPERRES_QTHRESH"]
    pub rc_superres_kf_qthresh: ::std::os::raw::c_uint,
    #[doc = "Rate control algorithm to use.\n\n Indicates whether the end usage of this stream is to be streamed over\n a bandwidth constrained link, indicating that Constant Bit Rate (CBR)\n mode should be used, or whether it will be played back on a high\n bandwidth link, as from a local disk, where higher variations in\n bitrate are acceptable."]
    pub rc_end_usage: aom_rc_mode,
    #[doc = "Two-pass stats buffer.\n\n A buffer containing all of the stats packets produced in the first\n pass, concatenated."]
    pub rc_twopass_stats_in: aom_fixed_buf_t,
    #[doc = "first pass mb stats buffer.\n\n A buffer containing all of the first pass mb stats packets produced\n in the first pass, concatenated."]
    pub rc_firstpass_mb_stats_in: aom_fixed_buf_t,
    #[doc = "Target data rate\n\n Target bitrate to use for this stream, in kilobits per second."]
    pub rc_target_bitrate: ::std::os::raw::c_uint,
    #[doc = "Minimum (Best Quality) Quantizer\n\n The quantizer is the most direct control over the quality of the\n encoded image. The range of valid values for the quantizer is codec\n specific. Consult the documentation for the codec to determine the\n values to use. To determine the range programmatically, call\n aom_codec_enc_config_default() with a usage value of 0."]
    pub rc_min_quantizer: ::std::os::raw::c_uint,
    #[doc = "Maximum (Worst Quality) Quantizer\n\n The quantizer is the most direct control over the quality of the\n encoded image. The range of valid values for the quantizer is codec\n specific. Consult the documentation for the codec to determine the\n values to use. To determine the range programmatically, call\n aom_codec_enc_config_default() with a usage value of 0."]
    pub rc_max_quantizer: ::std::os::raw::c_uint,
    #[doc = "Rate control adaptation undershoot control\n\n This value, controls the tolerance of the VBR algorithm to undershoot\n and is used as a trigger threshold for more aggressive adaptation of Q.\n\n Valid values in the range 0-100."]
    pub rc_undershoot_pct: ::std::os::raw::c_uint,
    #[doc = "Rate control adaptation overshoot control\n\n This value, controls the tolerance of the VBR algorithm to overshoot\n and is used as a trigger threshold for more aggressive adaptation of Q.\n\n Valid values in the range 0-100."]
    pub rc_overshoot_pct: ::std::os::raw::c_uint,
    #[doc = "Decoder Buffer Size\n\n This value indicates the amount of data that may be buffered by the\n decoding application. Note that this value is expressed in units of\n time (milliseconds). For example, a value of 5000 indicates that the\n client will buffer (at least) 5000ms worth of encoded data. Use the\n target bitrate (#rc_target_bitrate) to convert to bits/bytes, if\n necessary."]
    pub rc_buf_sz: ::std::os::raw::c_uint,
    #[doc = "Decoder Buffer Initial Size\n\n This value indicates the amount of data that will be buffered by the\n decoding application prior to beginning playback. This value is\n expressed in units of time (milliseconds). Use the target bitrate\n (#rc_target_bitrate) to convert to bits/bytes, if necessary."]
    pub rc_buf_initial_sz: ::std::os::raw::c_uint,
    #[doc = "Decoder Buffer Optimal Size\n\n This value indicates the amount of data that the encoder should try\n to maintain in the decoder's buffer. This value is expressed in units\n of time (milliseconds). Use the target bitrate (#rc_target_bitrate)\n to convert to bits/bytes, if necessary."]
    pub rc_buf_optimal_sz: ::std::os::raw::c_uint,
    #[doc = "Two-pass mode CBR/VBR bias\n\n Bias, expressed on a scale of 0 to 100, for determining target size\n for the current frame. The value 0 indicates the optimal CBR mode\n value should be used. The value 100 indicates the optimal VBR mode\n value should be used. Values in between indicate which way the\n encoder should \"lean.\""]
    pub rc_2pass_vbr_bias_pct: ::std::os::raw::c_uint,
    #[doc = "Two-pass mode per-GOP minimum bitrate\n\n This value, expressed as a percentage of the target bitrate, indicates\n the minimum bitrate to be used for a single GOP (aka \"section\")"]
    pub rc_2pass_vbr_minsection_pct: ::std::os::raw::c_uint,
    #[doc = "Two-pass mode per-GOP maximum bitrate\n\n This value, expressed as a percentage of the target bitrate, indicates\n the maximum bitrate to be used for a single GOP (aka \"section\")"]
    pub rc_2pass_vbr_maxsection_pct: ::std::os::raw::c_uint,
    #[doc = "Option to enable forward reference key frame\n"]
    pub fwd_kf_enabled: ::std::os::raw::c_int,
    #[doc = "Keyframe placement mode\n\n This value indicates whether the encoder should place keyframes at a\n fixed interval, or determine the optimal placement automatically\n (as governed by the #kf_min_dist and #kf_max_dist parameters)"]
    pub kf_mode: aom_kf_mode,
    #[doc = "Keyframe minimum interval\n\n This value, expressed as a number of frames, prevents the encoder from\n placing a keyframe nearer than kf_min_dist to the previous keyframe. At\n least kf_min_dist frames non-keyframes will be coded before the next\n keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval."]
    pub kf_min_dist: ::std::os::raw::c_uint,
    #[doc = "Keyframe maximum interval\n\n This value, expressed as a number of frames, forces the encoder to code\n a keyframe if one has not been coded in the last kf_max_dist frames.\n A value of 0 implies all frames will be keyframes. Set kf_min_dist\n equal to kf_max_dist for a fixed interval."]
    pub kf_max_dist: ::std::os::raw::c_uint,
    #[doc = "sframe interval\n\n This value, expressed as a number of frames, forces the encoder to code\n an S-Frame every sframe_dist frames."]
    pub sframe_dist: ::std::os::raw::c_uint,
    #[doc = "sframe insertion mode\n\n This value must be set to 1 or 2, and tells the encoder how to insert\n S-Frames. It will only have an effect if sframe_dist != 0.\n\n If altref is enabled:\n   - if sframe_mode == 1, the considered frame will be made into an\n     S-Frame only if it is an altref frame\n   - if sframe_mode == 2, the next altref frame will be made into an\n     S-Frame.\n\n Otherwise: the considered frame will be made into an S-Frame."]
    pub sframe_mode: ::std::os::raw::c_uint,
    #[doc = "Tile coding mode\n\n This value indicates the tile coding mode.\n A value of 0 implies a normal non-large-scale tile coding. A value of 1\n implies a large-scale tile coding."]
    pub large_scale_tile: ::std::os::raw::c_uint,
    #[doc = "Monochrome mode\n\n If this is nonzero, the encoder will generate a monochrome stream\n with no chroma planes."]
    pub monochrome: ::std::os::raw::c_uint,
    #[doc = "full_still_picture_hdr\n\n If this is nonzero, the encoder will generate a full header\n (reduced_still_picture_header is set to 0 in the sequence header OBU) even\n for still picture encoding. If this is zero (the default), a reduced\n header (reduced_still_picture_header is set to 1 in the sequence header\n OBU) is used for still picture encoding. This flag has no effect when a\n regular video with more than a single frame is encoded."]
    pub full_still_picture_hdr: ::std::os::raw::c_uint,
    #[doc = "Bitstream syntax mode\n\n This value indicates the bitstream syntax mode.\n A value of 0 indicates bitstream is saved as Section 5 bitstream. A value\n of 1 indicates the bitstream is saved in Annex-B format"]
    pub save_as_annexb: ::std::os::raw::c_uint,
    #[doc = "Number of explicit tile widths specified\n\n This value indicates the number of tile widths specified\n A value of 0 implies no tile widths are specified.\n Tile widths are given in the array tile_widths[]"]
    pub tile_width_count: ::std::os::raw::c_int,
    #[doc = "Number of explicit tile heights specified\n\n This value indicates the number of tile heights specified\n A value of 0 implies no tile heights are specified.\n Tile heights are given in the array tile_heights[]"]
    pub tile_height_count: ::std::os::raw::c_int,
    #[doc = "Array of specified tile widths\n\n This array specifies tile widths (and may be empty)\n The number of widths specified is given by tile_width_count"]
    pub tile_widths: [::std::os::raw::c_int; 64usize],
    #[doc = "Array of specified tile heights\n\n This array specifies tile heights (and may be empty)\n The number of heights specified is given by tile_height_count"]
    pub tile_heights: [::std::os::raw::c_int; 64usize],
    #[doc = "Whether encoder should use fixed QP offsets.\n\n If a value of 1 is provided, encoder will use fixed QP offsets for frames\n at different levels of the pyramid.\n If a value of 0 is provided, encoder will NOT use fixed QP offsets.\n Note: This option is only relevant for --end-usage=q."]
    pub use_fixed_qp_offsets: ::std::os::raw::c_uint,
    #[doc = "Deprecated and ignored. DO NOT USE.\n\n TODO(aomedia:3269): Remove fixed_qp_offsets in libaom v4.0.0."]
    pub fixed_qp_offsets: [::std::os::raw::c_int; 5usize],
    #[doc = "Options defined per config file\n"]
    pub encoder_cfg: cfg_options_t,
}
#[doc = "Encoder configuration structure\n\n This structure contains the encoder settings that have common representations\n across all codecs. This doesn't imply that all codecs support all features,\n however."]
pub type aom_codec_enc_cfg_t = aom_codec_enc_cfg;
extern "C" {
    #[doc = "Initialize an encoder instance\n\n Initializes an encoder context using the given interface. Applications\n should call the aom_codec_enc_init convenience macro instead of this\n function directly, to ensure that the ABI version number parameter\n is properly initialized.\n\n If the library was configured with -DCONFIG_MULTITHREAD=0, this call\n is not thread safe and should be guarded with a lock if being used\n in a multithreaded context.\n\n If aom_codec_enc_init_ver() fails, it is not necessary to call\n aom_codec_destroy() on the encoder context.\n\n \\param[in]    ctx     Pointer to this instance's context.\n \\param[in]    iface   Pointer to the algorithm interface to use.\n \\param[in]    cfg     Configuration to use, if known.\n \\param[in]    flags   Bitfield of AOM_CODEC_USE_* flags\n \\param[in]    ver     ABI version number. Must be set to\n                       AOM_ENCODER_ABI_VERSION\n \\retval #AOM_CODEC_OK\n     The encoder algorithm has been initialized.\n \\retval #AOM_CODEC_MEM_ERROR\n     Memory allocation failed."]
    pub fn aom_codec_enc_init_ver(
        ctx: *mut aom_codec_ctx_t,
        iface: *const aom_codec_iface,
        cfg: *const aom_codec_enc_cfg_t,
        flags: aom_codec_flags_t,
        ver: ::std::os::raw::c_int,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Get the default configuration for a usage.\n\n Initializes an encoder configuration structure with default values. Supports\n the notion of \"usages\" so that an algorithm may offer different default\n settings depending on the user's intended goal. This function \\ref SHOULD\n be called by all applications to initialize the configuration structure\n before specializing the configuration with application specific values.\n\n \\param[in]    iface     Pointer to the algorithm interface to use.\n \\param[out]   cfg       Configuration buffer to populate.\n \\param[in]    usage     Algorithm specific usage value. For AV1, must be\n                         set to AOM_USAGE_GOOD_QUALITY (0),\n                         AOM_USAGE_REALTIME (1), or AOM_USAGE_ALL_INTRA (2).\n\n \\retval #AOM_CODEC_OK\n     The configuration was populated.\n \\retval #AOM_CODEC_INCAPABLE\n     Interface is not an encoder interface.\n \\retval #AOM_CODEC_INVALID_PARAM\n     A parameter was NULL, or the usage value was not recognized."]
    pub fn aom_codec_enc_config_default(
        iface: *const aom_codec_iface,
        cfg: *mut aom_codec_enc_cfg_t,
        usage: ::std::os::raw::c_uint,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Set or change configuration\n\n Reconfigures an encoder instance according to the given configuration.\n\n \\param[in]    ctx     Pointer to this instance's context\n \\param[in]    cfg     Configuration buffer to use\n\n \\retval #AOM_CODEC_OK\n     The configuration was populated.\n \\retval #AOM_CODEC_INCAPABLE\n     Interface is not an encoder interface.\n \\retval #AOM_CODEC_INVALID_PARAM\n     A parameter was NULL, or the usage value was not recognized."]
    pub fn aom_codec_enc_config_set(
        ctx: *mut aom_codec_ctx_t,
        cfg: *const aom_codec_enc_cfg_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Get global stream headers\n\n Retrieves a stream level global header packet, if supported by the codec.\n Calls to this function should be deferred until all configuration information\n has been passed to libaom. Otherwise the global header data may be\n invalidated by additional configuration changes.\n\n The AV1 implementation of this function returns an OBU. The OBU returned is\n in Low Overhead Bitstream Format. Specifically, the obu_has_size_field bit is\n set, and the buffer contains the obu_size field for the returned OBU.\n\n \\param[in]    ctx     Pointer to this instance's context\n\n \\retval NULL\n     Encoder does not support global header, or an error occurred while\n     generating the global header.\n\n \\retval Non-NULL\n     Pointer to buffer containing global header packet. The caller owns the\n     memory associated with this buffer, and must free the 'buf' member of the\n     aom_fixed_buf_t as well as the aom_fixed_buf_t pointer. Memory returned\n     must be freed via call to free()."]
    pub fn aom_codec_get_global_headers(ctx: *mut aom_codec_ctx_t) -> *mut aom_fixed_buf_t;
}
extern "C" {
    #[doc = "Encode a frame\n\n Encodes a video frame at the given \"presentation time.\" The presentation\n time stamp (PTS) \\ref MUST be strictly increasing.\n\n When the last frame has been passed to the encoder, this function should\n continue to be called in a loop, with the img parameter set to NULL. This\n will signal the end-of-stream condition to the encoder and allow it to\n encode any held buffers. Encoding is complete when aom_codec_encode() is\n called with img set to NULL and aom_codec_get_cx_data() returns no data.\n\n \\param[in]    ctx       Pointer to this instance's context\n \\param[in]    img       Image data to encode, NULL to flush.\n                         Encoding sample values outside the range\n                         [0..(1<<img->bit_depth)-1] is undefined behavior.\n                         Note: Although img is declared as a const pointer,\n                         if AV1E_SET_DENOISE_NOISE_LEVEL is set to a nonzero\n                         value aom_codec_encode() modifies (denoises) the\n                         samples in img->planes[i] .\n \\param[in]    pts       Presentation time stamp, in timebase units. If img\n                         is NULL, pts is ignored.\n \\param[in]    duration  Duration to show frame, in timebase units. If img\n                         is not NULL, duration must be nonzero. If img is\n                         NULL, duration is ignored.\n \\param[in]    flags     Flags to use for encoding this frame.\n\n \\retval #AOM_CODEC_OK\n     The configuration was populated.\n \\retval #AOM_CODEC_INCAPABLE\n     Interface is not an encoder interface.\n \\retval #AOM_CODEC_INVALID_PARAM\n     A parameter was NULL, the image format is unsupported, etc."]
    pub fn aom_codec_encode(
        ctx: *mut aom_codec_ctx_t,
        img: *const aom_image_t,
        pts: aom_codec_pts_t,
        duration: ::std::os::raw::c_ulong,
        flags: aom_enc_frame_flags_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Set compressed data output buffer\n\n Sets the buffer that the codec should output the compressed data\n into. This call effectively sets the buffer pointer returned in the\n next AOM_CODEC_CX_FRAME_PKT packet. Subsequent packets will be\n appended into this buffer. The buffer is preserved across frames,\n so applications must periodically call this function after flushing\n the accumulated compressed data to disk or to the network to reset\n the pointer to the buffer's head.\n\n `pad_before` bytes will be skipped before writing the compressed\n data, and `pad_after` bytes will be appended to the packet. The size\n of the packet will be the sum of the size of the actual compressed\n data, pad_before, and pad_after. The padding bytes will be preserved\n (not overwritten).\n\n Note that calling this function does not guarantee that the returned\n compressed data will be placed into the specified buffer. In the\n event that the encoded data will not fit into the buffer provided,\n the returned packet \\ref MAY point to an internal buffer, as it would\n if this call were never used. In this event, the output packet will\n NOT have any padding, and the application must free space and copy it\n to the proper place. This is of particular note in configurations\n that may output multiple packets for a single encoded frame (e.g., lagged\n encoding) or if the application does not reset the buffer periodically.\n\n Applications may restore the default behavior of the codec providing\n the compressed data buffer by calling this function with a NULL\n buffer.\n\n Applications \\ref MUSTNOT call this function during iteration of\n aom_codec_get_cx_data().\n\n \\param[in]    ctx         Pointer to this instance's context\n \\param[in]    buf         Buffer to store compressed data into\n \\param[in]    pad_before  Bytes to skip before writing compressed data\n \\param[in]    pad_after   Bytes to skip after writing compressed data\n\n \\retval #AOM_CODEC_OK\n     The buffer was set successfully.\n \\retval #AOM_CODEC_INVALID_PARAM\n     A parameter was NULL, the image format is unsupported, etc."]
    pub fn aom_codec_set_cx_data_buf(
        ctx: *mut aom_codec_ctx_t,
        buf: *const aom_fixed_buf_t,
        pad_before: ::std::os::raw::c_uint,
        pad_after: ::std::os::raw::c_uint,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Encoded data iterator\n\n Iterates over a list of data packets to be passed from the encoder to the\n application. The different kinds of packets available are enumerated in\n #aom_codec_cx_pkt_kind.\n\n #AOM_CODEC_CX_FRAME_PKT packets should be passed to the application's\n muxer. Multiple compressed frames may be in the list.\n #AOM_CODEC_STATS_PKT packets should be appended to a global buffer.\n\n The application \\ref MUST silently ignore any packet kinds that it does\n not recognize or support.\n\n The data buffers returned from this function are only guaranteed to be\n valid until the application makes another call to any aom_codec_* function.\n\n \\param[in]     ctx      Pointer to this instance's context\n \\param[in,out] iter     Iterator storage, initialized to NULL\n\n \\return Returns a pointer to an output data packet (compressed frame data,\n         two-pass statistics, etc.) or NULL to signal end-of-list.\n"]
    pub fn aom_codec_get_cx_data(
        ctx: *mut aom_codec_ctx_t,
        iter: *mut aom_codec_iter_t,
    ) -> *const aom_codec_cx_pkt_t;
}
extern "C" {
    #[doc = "Get Preview Frame\n\n Returns an image that can be used as a preview. Shows the image as it would\n exist at the decompressor. The application \\ref MUST NOT write into this\n image buffer.\n\n \\param[in]     ctx      Pointer to this instance's context\n\n \\return Returns a pointer to a preview image, or NULL if no image is\n         available.\n"]
    pub fn aom_codec_get_preview_frame(ctx: *mut aom_codec_ctx_t) -> *const aom_image_t;
}
#[doc = "External frame buffer\n\n This structure holds allocated frame buffers used by the decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_frame_buffer {
    #[doc = "Pointer to the data buffer"]
    pub data: *mut u8,
    #[doc = "Size of data in bytes"]
    pub size: usize,
    #[doc = "Frame's private data"]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[doc = "External frame buffer\n\n This structure holds allocated frame buffers used by the decoder."]
pub type aom_codec_frame_buffer_t = aom_codec_frame_buffer;
#[doc = "get frame buffer callback prototype\n\n This callback is invoked by the decoder to retrieve data for the frame\n buffer in order for the decode call to complete. The callback must\n allocate at least min_size in bytes and assign it to fb->data. The callback\n must zero out all the data allocated. Then the callback must set fb->size\n to the allocated size. The application does not need to align the allocated\n data. The callback is triggered when the decoder needs a frame buffer to\n decode a compressed image into. This function may be called more than once\n for every call to aom_codec_decode. The application may set fb->priv to\n some data which will be passed back in the aom_image_t and the release\n function call. |fb| is guaranteed to not be NULL. On success the callback\n must return 0. Any failure the callback must return a value less than 0.\n\n \\param[in] priv         Callback's private data\n \\param[in] min_size     Size in bytes needed by the buffer\n \\param[in,out] fb       Pointer to aom_codec_frame_buffer_t"]
pub type aom_get_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        min_size: usize,
        fb: *mut aom_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "release frame buffer callback prototype\n\n This callback is invoked by the decoder when the frame buffer is not\n referenced by any other buffers. |fb| is guaranteed to not be NULL. On\n success the callback must return 0. Any failure the callback must return\n a value less than 0.\n\n \\param[in] priv         Callback's private data\n \\param[in] fb           Pointer to aom_codec_frame_buffer_t"]
pub type aom_release_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        fb: *mut aom_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Stream properties\n\n This structure is used to query or set properties of the decoded\n stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_stream_info {
    #[doc = "Width (or 0 for unknown/default)"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "Height (or 0 for unknown/default)"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "Current frame is a keyframe"]
    pub is_kf: ::std::os::raw::c_uint,
    #[doc = "Number of spatial layers"]
    pub number_spatial_layers: ::std::os::raw::c_uint,
    #[doc = "Number of temporal layers"]
    pub number_temporal_layers: ::std::os::raw::c_uint,
    #[doc = "Is Bitstream in Annex-B format"]
    pub is_annexb: ::std::os::raw::c_uint,
}
#[doc = "Stream properties\n\n This structure is used to query or set properties of the decoded\n stream."]
pub type aom_codec_stream_info_t = aom_codec_stream_info;
#[doc = "Initialization Configurations\n\n This structure is used to pass init time configuration options to the\n decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_dec_cfg {
    #[doc = "Maximum number of threads to use, default 1"]
    pub threads: ::std::os::raw::c_uint,
    #[doc = "Width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "Height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "Allow use of low-bitdepth coding path"]
    pub allow_lowbitdepth: ::std::os::raw::c_uint,
}
#[doc = "Initialization Configurations\n\n This structure is used to pass init time configuration options to the\n decoder."]
pub type aom_codec_dec_cfg_t = aom_codec_dec_cfg;
extern "C" {
    #[doc = "Initialize a decoder instance\n\n Initializes a decoder context using the given interface. Applications\n should call the aom_codec_dec_init convenience macro instead of this\n function directly, to ensure that the ABI version number parameter\n is properly initialized.\n\n If the library was configured with cmake -DCONFIG_MULTITHREAD=0, this\n call is not thread safe and should be guarded with a lock if being used\n in a multithreaded context.\n\n \\param[in]    ctx     Pointer to this instance's context.\n \\param[in]    iface   Pointer to the algorithm interface to use.\n \\param[in]    cfg     Configuration to use, if known. May be NULL.\n \\param[in]    flags   Bitfield of AOM_CODEC_USE_* flags\n \\param[in]    ver     ABI version number. Must be set to\n                       AOM_DECODER_ABI_VERSION\n \\retval #AOM_CODEC_OK\n     The decoder algorithm has been initialized.\n \\retval #AOM_CODEC_MEM_ERROR\n     Memory allocation failed."]
    pub fn aom_codec_dec_init_ver(
        ctx: *mut aom_codec_ctx_t,
        iface: *const aom_codec_iface,
        cfg: *const aom_codec_dec_cfg_t,
        flags: aom_codec_flags_t,
        ver: ::std::os::raw::c_int,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Parse stream info from a buffer\n\n Performs high level parsing of the bitstream. Construction of a decoder\n context is not necessary. Can be used to determine if the bitstream is\n of the proper format, and to extract information from the stream.\n\n \\param[in]      iface   Pointer to the algorithm interface\n \\param[in]      data    Pointer to a block of data to parse\n \\param[in]      data_sz Size of the data buffer\n \\param[in,out]  si      Pointer to stream info to update. The is_annexb\n                         member \\ref MUST be properly initialized. This\n                         function sets the rest of the members.\n\n \\retval #AOM_CODEC_OK\n     Bitstream is parsable and stream information updated.\n \\retval #AOM_CODEC_INVALID_PARAM\n     One of the arguments is invalid, for example a NULL pointer.\n \\retval #AOM_CODEC_UNSUP_BITSTREAM\n     The decoder didn't recognize the coded data, or the\n     buffer was too short."]
    pub fn aom_codec_peek_stream_info(
        iface: *const aom_codec_iface,
        data: *const u8,
        data_sz: usize,
        si: *mut aom_codec_stream_info_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Return information about the current stream.\n\n Returns information about the stream that has been parsed during decoding.\n\n \\param[in]      ctx     Pointer to this instance's context\n \\param[in,out]  si      Pointer to stream info to update.\n\n \\retval #AOM_CODEC_OK\n     Bitstream is parsable and stream information updated.\n \\retval #AOM_CODEC_INVALID_PARAM\n     One of the arguments is invalid, for example a NULL pointer.\n \\retval #AOM_CODEC_UNSUP_BITSTREAM\n     The decoder couldn't parse the submitted data."]
    pub fn aom_codec_get_stream_info(
        ctx: *mut aom_codec_ctx_t,
        si: *mut aom_codec_stream_info_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Decode data\n\n Processes a buffer of coded data. Encoded data \\ref MUST be passed in DTS\n (decode time stamp) order. Frames produced will always be in PTS\n (presentation time stamp) order.\n\n \\param[in] ctx          Pointer to this instance's context\n \\param[in] data         Pointer to this block of new coded data.\n \\param[in] data_sz      Size of the coded data, in bytes.\n \\param[in] user_priv    Application specific data to associate with\n                         this frame.\n\n \\return Returns #AOM_CODEC_OK if the coded data was processed completely\n         and future pictures can be decoded without error. Otherwise,\n         see the descriptions of the other error codes in ::aom_codec_err_t\n         for recoverability capabilities."]
    pub fn aom_codec_decode(
        ctx: *mut aom_codec_ctx_t,
        data: *const u8,
        data_sz: usize,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "Decoded frames iterator\n\n Iterates over a list of the frames available for display. The iterator\n storage should be initialized to NULL to start the iteration. Iteration is\n complete when this function returns NULL.\n\n The list of available frames becomes valid upon completion of the\n aom_codec_decode call, and remains valid until the next call to\n aom_codec_decode.\n\n \\param[in]     ctx      Pointer to this instance's context\n \\param[in,out] iter     Iterator storage, initialized to NULL\n\n \\return Returns a pointer to an image, if one is ready for display. Frames\n         produced will always be in PTS (presentation time stamp) order."]
    pub fn aom_codec_get_frame(
        ctx: *mut aom_codec_ctx_t,
        iter: *mut aom_codec_iter_t,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "Pass in external frame buffers for the decoder to use.\n\n Registers functions to be called when libaom needs a frame buffer\n to decode the current frame and a function to be called when libaom does\n not internally reference the frame buffer. This set function must\n be called before the first call to decode or libaom will assume the\n default behavior of allocating frame buffers internally.\n\n \\param[in] ctx          Pointer to this instance's context\n \\param[in] cb_get       Pointer to the get callback function\n \\param[in] cb_release   Pointer to the release callback function\n \\param[in] cb_priv      Callback's private data\n\n \\retval #AOM_CODEC_OK\n     External frame buffers will be used by libaom.\n \\retval #AOM_CODEC_INVALID_PARAM\n     One or more of the callbacks were NULL.\n \\retval #AOM_CODEC_ERROR\n     Decoder context not initialized.\n \\retval #AOM_CODEC_INCAPABLE\n     Algorithm not capable of using external frame buffers.\n\n \\note\n When decoding AV1, the application may be required to pass in at least\n #AOM_MAXIMUM_WORK_BUFFERS external frame buffers."]
    pub fn aom_codec_set_frame_buffer_functions(
        ctx: *mut aom_codec_ctx_t,
        cb_get: aom_get_frame_buffer_cb_fn_t,
        cb_release: aom_release_frame_buffer_cb_fn_t,
        cb_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "A single instance of the AV1 encoder.\n\\deprecated This access mechanism is provided for backwards compatibility;\n prefer aom_codec_av1_cx()."]
    pub static mut aom_codec_av1_cx_algo: aom_codec_iface_t;
}
extern "C" {
    #[doc = "The interface to the AV1 encoder."]
    pub fn aom_codec_av1_cx() -> *const aom_codec_iface;
}
#[doc = "Codec control function to set which reference frame encoder can use,\n int parameter."]
pub const AOME_USE_REFERENCE: aome_enc_control_id = 7;
#[doc = "Codec control function to pass an ROI map to encoder, aom_roi_map_t*\n parameter."]
pub const AOME_SET_ROI_MAP: aome_enc_control_id = 8;
#[doc = "Codec control function to pass an Active map to encoder,\n aom_active_map_t* parameter."]
pub const AOME_SET_ACTIVEMAP: aome_enc_control_id = 9;
#[doc = "Codec control function to set encoder scaling mode for the next\n frame to be coded, aom_scaling_mode_t* parameter."]
pub const AOME_SET_SCALEMODE: aome_enc_control_id = 11;
#[doc = "Codec control function to set encoder spatial layer id, int\n parameter."]
pub const AOME_SET_SPATIAL_LAYER_ID: aome_enc_control_id = 12;
#[doc = "Codec control function to set encoder internal speed settings,\n int parameter\n\n Changes in this value influences the complexity of algorithms used in\n encoding process, values greater than 0 will increase encoder speed at\n the expense of quality.\n\n Valid range: 0..10. 0 runs the slowest, and 10 runs the fastest;\n quality improves as speed decreases (since more compression\n possibilities are explored).\n\n NOTE: 10 is only allowed in AOM_USAGE_REALTIME. In AOM_USAGE_GOOD_QUALITY\n and AOM_USAGE_ALL_INTRA, 9 is the highest allowed value. However,\n AOM_USAGE_GOOD_QUALITY treats 7..9 the same as 6. Also, AOM_USAGE_REALTIME\n treats 0..4 the same as 5."]
pub const AOME_SET_CPUUSED: aome_enc_control_id = 13;
#[doc = "Codec control function to enable automatic set and use alf frames,\n unsigned int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AOME_SET_ENABLEAUTOALTREF: aome_enc_control_id = 14;
#[doc = "Codec control function to set the sharpness parameter,\n unsigned int parameter.\n\n This parameter controls the level at which rate-distortion optimization of\n transform coefficients favours sharpness in the block.\n\n Valid range: 0..7. The default is 0. Values 1-7 will avoid eob and skip\n block optimization and will change rdmult in favour of block sharpness."]
pub const AOME_SET_SHARPNESS: aome_enc_control_id = 16;
#[doc = "Codec control function to set the threshold for MBs treated static,\n unsigned int parameter"]
pub const AOME_SET_STATIC_THRESHOLD: aome_enc_control_id = 17;
#[doc = "Codec control function to get last quantizer chosen by the encoder,\n int* parameter\n\n Return value uses internal quantizer scale defined by the codec."]
pub const AOME_GET_LAST_QUANTIZER: aome_enc_control_id = 19;
#[doc = "Codec control function to get last quantizer chosen by the encoder,\n int* parameter\n\n Return value uses the 0..63 scale as used by the rc_*_quantizer config\n parameters."]
pub const AOME_GET_LAST_QUANTIZER_64: aome_enc_control_id = 20;
#[doc = "Codec control function to set the max no of frames to create arf,\n unsigned int parameter"]
pub const AOME_SET_ARNR_MAXFRAMES: aome_enc_control_id = 21;
#[doc = "Codec control function to set the filter strength for the arf,\n unsigned int parameter"]
pub const AOME_SET_ARNR_STRENGTH: aome_enc_control_id = 22;
#[doc = "Codec control function to set visual tuning, aom_tune_metric (int)\n parameter\n\n The default is AOM_TUNE_PSNR."]
pub const AOME_SET_TUNING: aome_enc_control_id = 24;
#[doc = "Codec control function to set constrained / constant quality level,\n unsigned int parameter\n\n Valid range: 0..63\n\n \\attention For this value to be used aom_codec_enc_cfg_t::rc_end_usage\n            must be set to #AOM_CQ or #AOM_Q."]
pub const AOME_SET_CQ_LEVEL: aome_enc_control_id = 25;
#[doc = "Codec control function to set max data rate for intra frames,\n unsigned int parameter\n\n This value controls additional clamping on the maximum size of a\n keyframe. It is expressed as a percentage of the average\n per-frame bitrate, with the special (and default) value 0 meaning\n unlimited, or no additional clamping beyond the codec's built-in\n algorithm.\n\n For example, to allocate no more than 4.5 frames worth of bitrate\n to a keyframe, set this to 450."]
pub const AOME_SET_MAX_INTRA_BITRATE_PCT: aome_enc_control_id = 26;
#[doc = "Codec control function to set number of spatial layers, int\n parameter"]
pub const AOME_SET_NUMBER_SPATIAL_LAYERS: aome_enc_control_id = 27;
#[doc = "Codec control function to set max data rate for inter frames,\n unsigned int parameter\n\n This value controls additional clamping on the maximum size of an\n inter frame. It is expressed as a percentage of the average\n per-frame bitrate, with the special (and default) value 0 meaning\n unlimited, or no additional clamping beyond the codec's built-in\n algorithm.\n\n For example, to allow no more than 4.5 frames worth of bitrate\n to an inter frame, set this to 450."]
pub const AV1E_SET_MAX_INTER_BITRATE_PCT: aome_enc_control_id = 28;
#[doc = "Boost percentage for Golden Frame in CBR mode, unsigned int\n parameter\n\n This value controls the amount of boost given to Golden Frame in\n CBR mode. It is expressed as a percentage of the average\n per-frame bitrate, with the special (and default) value 0 meaning\n the feature is off, i.e., no golden frame boost in CBR mode and\n average bitrate target is used.\n\n For example, to allow 100% more bits, i.e, 2X, in a golden frame\n than average frame, set this to 100."]
pub const AV1E_SET_GF_CBR_BOOST_PCT: aome_enc_control_id = 29;
#[doc = "Codec control function to set lossless encoding mode, unsigned int\n parameter\n\n AV1 can operate in lossless encoding mode, in which the bitstream\n produced will be able to decode and reconstruct a perfect copy of\n input source.\n\n - 0 = normal coding mode, may be lossy (default)\n - 1 = lossless coding mode"]
pub const AV1E_SET_LOSSLESS: aome_enc_control_id = 31;
#[doc = "Codec control function to enable the row based multi-threading\n of the encoder, unsigned int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ROW_MT: aome_enc_control_id = 32;
#[doc = "Codec control function to set number of tile columns. unsigned int\n parameter\n\n In encoding and decoding, AV1 allows an input image frame be partitioned\n into separate vertical tile columns, which can be encoded or decoded\n independently. This enables easy implementation of parallel encoding and\n decoding. The parameter for this control describes the number of tile\n columns (in log2 units), which has a valid range of [0, 6]:\n \\verbatim\n0 = 1 tile column\n1 = 2 tile columns\n2 = 4 tile columns\n.....\nn = 2**n tile columns\n\\endverbatim\n By default, the value is 0, i.e. one single column tile for entire image."]
pub const AV1E_SET_TILE_COLUMNS: aome_enc_control_id = 33;
#[doc = "Codec control function to set number of tile rows, unsigned int\n parameter\n\n In encoding and decoding, AV1 allows an input image frame be partitioned\n into separate horizontal tile rows, which can be encoded or decoded\n independently. The parameter for this control describes the number of tile\n rows (in log2 units), which has a valid range of [0, 6]:\n \\verbatim\n0 = 1 tile row\n1 = 2 tile rows\n2 = 4 tile rows\n.....\nn = 2**n tile rows\n\\endverbatim\n By default, the value is 0, i.e. one single row tile for entire image."]
pub const AV1E_SET_TILE_ROWS: aome_enc_control_id = 34;
#[doc = "Codec control function to enable RDO modulated by frame temporal\n dependency, unsigned int parameter\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ENABLE_TPL_MODEL: aome_enc_control_id = 35;
#[doc = "Codec control function to enable temporal filtering on key frame,\n unsigned int parameter\n\n - 0 = disable\n - 1 = enable without overlay (default)\n - 2 = enable with overlay"]
pub const AV1E_SET_ENABLE_KEYFRAME_FILTERING: aome_enc_control_id = 36;
#[doc = "Codec control function to enable frame parallel decoding feature,\n unsigned int parameter\n\n AV1 has a bitstream feature to reduce decoding dependency between frames\n by turning off backward update of probability context used in encoding\n and decoding. This allows staged parallel processing of more than one\n video frames in the decoder. This control function provides a means to\n turn this feature on or off for bitstreams produced by encoder.\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_FRAME_PARALLEL_DECODING: aome_enc_control_id = 37;
#[doc = "Codec control function to enable error_resilient_mode, int parameter\n\n AV1 has a bitstream feature to guarantee parsability of a frame\n by turning on the error_resilient_decoding mode, even though the\n reference buffers are unreliable or not received.\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_ERROR_RESILIENT_MODE: aome_enc_control_id = 38;
#[doc = "Codec control function to enable s_frame_mode, int parameter\n\n AV1 has a bitstream feature to designate certain frames as S-frames,\n from where we can switch to a different stream,\n even though the reference buffers may not be exactly identical.\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_S_FRAME_MODE: aome_enc_control_id = 39;
#[doc = "Codec control function to set adaptive quantization mode, unsigned\n int parameter\n\n AV1 has a segment based feature that allows encoder to adaptively change\n quantization parameter for each segment within a frame to improve the\n subjective quality. This control makes encoder operate in one of the\n several AQ modes supported.\n\n - 0 = disable (default)\n - 1 = variance\n - 2 = complexity\n - 3 = cyclic refresh"]
pub const AV1E_SET_AQ_MODE: aome_enc_control_id = 40;
#[doc = "Codec control function to enable/disable periodic Q boost, unsigned\n int parameter\n\n One AV1 encoder speed feature is to enable quality boost by lowering\n frame level Q periodically. This control function provides a means to\n turn on/off this feature.\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_FRAME_PERIODIC_BOOST: aome_enc_control_id = 41;
#[doc = "Codec control function to set noise sensitivity, unsigned int\n parameter\n\n - 0 = disable (default)\n - 1 = enable (Y only)"]
pub const AV1E_SET_NOISE_SENSITIVITY: aome_enc_control_id = 42;
#[doc = "Codec control function to set content type, aom_tune_content\n parameter\n\n  - AOM_CONTENT_DEFAULT = Regular video content (default)\n  - AOM_CONTENT_SCREEN  = Screen capture content\n  - AOM_CONTENT_FILM = Film content"]
pub const AV1E_SET_TUNE_CONTENT: aome_enc_control_id = 43;
#[doc = "Codec control function to set CDF update mode, unsigned int\n parameter\n\n  - 0: no update\n  - 1: update on every frame (default)\n  - 2: selectively update"]
pub const AV1E_SET_CDF_UPDATE_MODE: aome_enc_control_id = 44;
#[doc = "Codec control function to set color space info, int parameter\n\n  - 0 = For future use\n  - 1 = BT.709\n  - 2 = Unspecified (default)\n  - 3 = For future use\n  - 4 = BT.470 System M (historical)\n  - 5 = BT.470 System B, G (historical)\n  - 6 = BT.601\n  - 7 = SMPTE 240\n  - 8 = Generic film (color filters using illuminant C)\n  - 9 = BT.2020, BT.2100\n  - 10 = SMPTE 428 (CIE 1921 XYZ)\n  - 11 = SMPTE RP 431-2\n  - 12 = SMPTE EG 432-1\n  - 13..21 = For future use\n  - 22 = EBU Tech. 3213-E\n  - 23 = For future use"]
pub const AV1E_SET_COLOR_PRIMARIES: aome_enc_control_id = 45;
#[doc = "Codec control function to set transfer function info, int parameter\n\n - 0 = For future use\n - 1 = BT.709\n - 2 = Unspecified (default)\n - 3 = For future use\n - 4 = BT.470 System M (historical)\n - 5 = BT.470 System B, G (historical)\n - 6 = BT.601\n - 7 = SMPTE 240 M\n - 8 = Linear\n - 9 = Logarithmic (100 : 1 range)\n - 10 = Logarithmic (100 * Sqrt(10) : 1 range)\n - 11 = IEC 61966-2-4\n - 12 = BT.1361\n - 13 = sRGB or sYCC\n - 14 = BT.2020 10-bit systems\n - 15 = BT.2020 12-bit systems\n - 16 = SMPTE ST 2084, ITU BT.2100 PQ\n - 17 = SMPTE ST 428\n - 18 = BT.2100 HLG, ARIB STD-B67\n - 19 = For future use"]
pub const AV1E_SET_TRANSFER_CHARACTERISTICS: aome_enc_control_id = 46;
#[doc = "Codec control function to set transfer function info, int parameter\n\n - 0 = Identity matrix\n - 1 = BT.709\n - 2 = Unspecified (default)\n - 3 = For future use\n - 4 = US FCC 73.628\n - 5 = BT.470 System B, G (historical)\n - 6 = BT.601\n - 7 = SMPTE 240 M\n - 8 = YCgCo\n - 9 = BT.2020 non-constant luminance, BT.2100 YCbCr\n - 10 = BT.2020 constant luminance\n - 11 = SMPTE ST 2085 YDzDx\n - 12 = Chromaticity-derived non-constant luminance\n - 13 = Chromaticity-derived constant luminance\n - 14 = BT.2100 ICtCp\n - 15 = For future use"]
pub const AV1E_SET_MATRIX_COEFFICIENTS: aome_enc_control_id = 47;
#[doc = "Codec control function to set chroma 4:2:0 sample position info,\n aom_chroma_sample_position_t parameter\n\n AOM_CSP_UNKNOWN is default"]
pub const AV1E_SET_CHROMA_SAMPLE_POSITION: aome_enc_control_id = 48;
#[doc = "Codec control function to set minimum interval between GF/ARF\n frames, unsigned int parameter\n\n By default the value is set as 4."]
pub const AV1E_SET_MIN_GF_INTERVAL: aome_enc_control_id = 49;
#[doc = "Codec control function to set minimum interval between GF/ARF\n frames, unsigned int parameter\n\n By default the value is set as 16."]
pub const AV1E_SET_MAX_GF_INTERVAL: aome_enc_control_id = 50;
#[doc = "Codec control function to get an active map back from the encoder,\naom_active_map_t* parameter"]
pub const AV1E_GET_ACTIVEMAP: aome_enc_control_id = 51;
#[doc = "Codec control function to set color range bit, int parameter\n\n - 0 = Limited range, 16..235 or HBD equivalent (default)\n - 1 = Full range, 0..255 or HBD equivalent"]
pub const AV1E_SET_COLOR_RANGE: aome_enc_control_id = 52;
#[doc = "Codec control function to set intended rendering image size,\n int32_t[2] parameter\n\n By default, this is identical to the image size in pixels."]
pub const AV1E_SET_RENDER_SIZE: aome_enc_control_id = 53;
#[doc = "Control to set target sequence level index for a certain operating\n point (OP), int parameter\n Possible values are in the form of \"ABxy\".\n  - AB: OP index.\n  - xy: Target level index for the OP. Possible values are:\n    + 0~27: corresponding to level 2.0 ~ 8.3. Note:\n      > Levels 2.2 (2), 2.3 (3), 3.2 (6), 3.3 (7), 4.2 (10) & 4.3 (11) are\n        undefined.\n      > Levels 7.x and 8.x (20~27) are in draft status, available under the\n        config flag CONFIG_CWG_C013.\n    + 31: maximum parameters level, no level-based constraints.\n    + 32: keep level stats only for level monitoring.\n\n E.g.:\n - \"0\" means target level index 0 (2.0) for the 0th OP;\n - \"109\" means target level index 9 (4.1) for the 1st OP;\n - \"1019\" means target level index 19 (6.3) for the 10th OP.\n\n If the target level is not specified for an OP, the maximum parameters\n level of 31 is used as default."]
pub const AV1E_SET_TARGET_SEQ_LEVEL_IDX: aome_enc_control_id = 54;
#[doc = "Codec control function to get sequence level index for each\n operating point. int* parameter. There can be at most 32 operating points.\n The results will be written into a provided integer array of sufficient\n size."]
pub const AV1E_GET_SEQ_LEVEL_IDX: aome_enc_control_id = 55;
#[doc = "Codec control function to set intended superblock size, unsigned int\n parameter\n\n By default, the superblock size is determined separately for each\n frame by the encoder."]
pub const AV1E_SET_SUPERBLOCK_SIZE: aome_enc_control_id = 56;
#[doc = "Codec control function to enable automatic set and use of\n bwd-pred frames, unsigned int parameter\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AOME_SET_ENABLEAUTOBWDREF: aome_enc_control_id = 57;
#[doc = "Codec control function to encode with CDEF, unsigned int parameter\n\n CDEF is the constrained directional enhancement filter which is an\n in-loop filter aiming to remove coding artifacts\n\n - 0 = disable\n - 1 = enable for all frames (default)\n - 2 = disable for non-reference frames"]
pub const AV1E_SET_ENABLE_CDEF: aome_enc_control_id = 58;
#[doc = "Codec control function to encode with Loop Restoration Filter,\n unsigned int parameter\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ENABLE_RESTORATION: aome_enc_control_id = 59;
#[doc = "Codec control function to force video mode, unsigned int parameter\n\n - 0 = do not force video mode (default)\n - 1 = force video mode even for a single frame"]
pub const AV1E_SET_FORCE_VIDEO_MODE: aome_enc_control_id = 60;
#[doc = "Codec control function to predict with OBMC mode, unsigned int\n parameter\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ENABLE_OBMC: aome_enc_control_id = 61;
#[doc = "Codec control function to encode without trellis quantization,\n unsigned int parameter\n\n - 0 = apply trellis quantization (default)\n - 1 = do not apply trellis quantization\n - 2 = disable trellis quantization in rd search\n - 3 = disable trellis quantization in estimate yrd"]
pub const AV1E_SET_DISABLE_TRELLIS_QUANT: aome_enc_control_id = 62;
#[doc = "Codec control function to encode with quantisation matrices,\n unsigned int parameter\n\n AOM can operate with default quantisation matrices dependent on\n quantisation level and block type.\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_ENABLE_QM: aome_enc_control_id = 63;
#[doc = "Codec control function to set the min quant matrix flatness,\n unsigned int parameter\n\n AOM can operate with different ranges of quantisation matrices.\n As quantisation levels increase, the matrices get flatter. This\n control sets the minimum level of flatness from which the matrices\n are determined.\n\n By default, the encoder sets this minimum at half the available\n range."]
pub const AV1E_SET_QM_MIN: aome_enc_control_id = 64;
#[doc = "Codec control function to set the max quant matrix flatness,\n unsigned int parameter\n\n AOM can operate with different ranges of quantisation matrices.\n As quantisation levels increase, the matrices get flatter. This\n control sets the maximum level of flatness possible.\n\n By default, the encoder sets this maximum at the top of the\n available range."]
pub const AV1E_SET_QM_MAX: aome_enc_control_id = 65;
#[doc = "Codec control function to set the min quant matrix flatness,\n unsigned int parameter\n\n AOM can operate with different ranges of quantisation matrices.\n As quantisation levels increase, the matrices get flatter. This\n control sets the flatness for luma (Y).\n\n By default, the encoder sets this minimum at half the available\n range."]
pub const AV1E_SET_QM_Y: aome_enc_control_id = 66;
#[doc = "Codec control function to set the min quant matrix flatness,\n unsigned int parameter\n\n AOM can operate with different ranges of quantisation matrices.\n As quantisation levels increase, the matrices get flatter. This\n control sets the flatness for chroma (U).\n\n By default, the encoder sets this minimum at half the available\n range."]
pub const AV1E_SET_QM_U: aome_enc_control_id = 67;
#[doc = "Codec control function to set the min quant matrix flatness,\n unsigned int parameter\n\n AOM can operate with different ranges of quantisation matrices.\n As quantisation levels increase, the matrices get flatter. This\n control sets the flatness for chrome (V).\n\n By default, the encoder sets this minimum at half the available\n range."]
pub const AV1E_SET_QM_V: aome_enc_control_id = 68;
#[doc = "Codec control function to set a maximum number of tile groups,\n unsigned int parameter\n\n This will set the maximum number of tile groups. This will be\n overridden if an MTU size is set. The default value is 1."]
pub const AV1E_SET_NUM_TG: aome_enc_control_id = 70;
#[doc = "Codec control function to set an MTU size for a tile group, unsigned\n int parameter\n\n This will set the maximum number of bytes in a tile group. This can be\n exceeded only if a single tile is larger than this amount.\n\n By default, the value is 0, in which case a fixed number of tile groups\n is used."]
pub const AV1E_SET_MTU: aome_enc_control_id = 71;
#[doc = "Codec control function to enable/disable rectangular partitions, int\n parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_RECT_PARTITIONS: aome_enc_control_id = 73;
#[doc = "Codec control function to enable/disable AB partitions, int\n parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_AB_PARTITIONS: aome_enc_control_id = 74;
#[doc = "Codec control function to enable/disable 1:4 and 4:1 partitions, int\n parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_1TO4_PARTITIONS: aome_enc_control_id = 75;
#[doc = "Codec control function to set min partition size, int parameter\n\n min_partition_size is applied to both width and height of the partition.\n i.e, both width and height of a partition can not be smaller than\n the min_partition_size, except the partition at the picture boundary.\n\n Valid values: [4, 8, 16, 32, 64, 128]. The default value is 4 for\n 4x4."]
pub const AV1E_SET_MIN_PARTITION_SIZE: aome_enc_control_id = 76;
#[doc = "Codec control function to set max partition size, int parameter\n\n max_partition_size is applied to both width and height of the partition.\n i.e, both width and height of a partition can not be larger than\n the max_partition_size.\n\n Valid values:[4, 8, 16, 32, 64, 128] The default value is 128 for\n 128x128."]
pub const AV1E_SET_MAX_PARTITION_SIZE: aome_enc_control_id = 77;
#[doc = "Codec control function to turn on / off intra edge filter\n at sequence level, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_INTRA_EDGE_FILTER: aome_enc_control_id = 78;
#[doc = "Codec control function to turn on / off frame order hint (int\n parameter). Affects: joint compound mode, motion field motion vector,\n ref frame sign bias\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_ORDER_HINT: aome_enc_control_id = 79;
#[doc = "Codec control function to turn on / off 64-length transforms, int\n parameter\n\n This will enable or disable usage of length 64 transforms in any\n direction.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_TX64: aome_enc_control_id = 80;
#[doc = "Codec control function to turn on / off flip and identity\n transforms, int parameter\n\n This will enable or disable usage of flip and identity transform\n types in any direction. If enabled, this includes:\n - FLIPADST_DCT\n - DCT_FLIPADST\n - FLIPADST_FLIPADST\n - ADST_FLIPADST\n - FLIPADST_ADST\n - IDTX\n - V_DCT\n - H_DCT\n - V_ADST\n - H_ADST\n - V_FLIPADST\n - H_FLIPADST\n\n Valid values:\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_FLIP_IDTX: aome_enc_control_id = 81;
#[doc = "Codec control function to turn on / off rectangular transforms, int\n parameter\n\n This will enable or disable usage of rectangular transforms. NOTE:\n Rectangular transforms only enabled when corresponding rectangular\n partitions are.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_RECT_TX: aome_enc_control_id = 82;
#[doc = "Codec control function to turn on / off dist-wtd compound mode\n at sequence level, int parameter\n\n This will enable or disable distance-weighted compound mode.\n \\attention If AV1E_SET_ENABLE_ORDER_HINT is 0, then this flag is forced\n to 0.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_DIST_WTD_COMP: aome_enc_control_id = 83;
#[doc = "Codec control function to turn on / off ref frame mvs (mfmv) usage\n at sequence level, int parameter\n\n \\attention If AV1E_SET_ENABLE_ORDER_HINT is 0, then this flag is forced\n to 0.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_REF_FRAME_MVS: aome_enc_control_id = 84;
#[doc = "Codec control function to set temporal mv prediction\n enabling/disabling at frame level, int parameter\n\n \\attention If AV1E_SET_ENABLE_REF_FRAME_MVS is 0, then this flag is\n forced to 0.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ALLOW_REF_FRAME_MVS: aome_enc_control_id = 85;
#[doc = "Codec control function to turn on / off dual interpolation filter\n for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable"]
pub const AV1E_SET_ENABLE_DUAL_FILTER: aome_enc_control_id = 86;
#[doc = "Codec control function to turn on / off delta quantization in chroma\n planes for a sequence, int parameter\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_ENABLE_CHROMA_DELTAQ: aome_enc_control_id = 87;
#[doc = "Codec control function to turn on / off masked compound usage\n (wedge and diff-wtd compound modes) for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_MASKED_COMP: aome_enc_control_id = 88;
#[doc = "Codec control function to turn on / off one sided compound usage\n for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_ONESIDED_COMP: aome_enc_control_id = 89;
#[doc = "Codec control function to turn on / off interintra compound\n for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_INTERINTRA_COMP: aome_enc_control_id = 90;
#[doc = "Codec control function to turn on / off smooth inter-intra\n mode for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_SMOOTH_INTERINTRA: aome_enc_control_id = 91;
#[doc = "Codec control function to turn on / off difference weighted\n compound, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_DIFF_WTD_COMP: aome_enc_control_id = 92;
#[doc = "Codec control function to turn on / off interinter wedge\n compound, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_INTERINTER_WEDGE: aome_enc_control_id = 93;
#[doc = "Codec control function to turn on / off interintra wedge\n compound, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_INTERINTRA_WEDGE: aome_enc_control_id = 94;
#[doc = "Codec control function to turn on / off global motion usage\n for a sequence, int parameter\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ENABLE_GLOBAL_MOTION: aome_enc_control_id = 95;
#[doc = "Codec control function to turn on / off warped motion usage\n at sequence level, int parameter\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ENABLE_WARPED_MOTION: aome_enc_control_id = 96;
#[doc = "Codec control function to turn on / off warped motion usage\n at frame level, int parameter\n\n \\attention If AV1E_SET_ENABLE_WARPED_MOTION is 0, then this flag is\n forced to 0.\n\n - 0 = disable\n - 1 = enable (default)\n\n \\note Excluded from CONFIG_REALTIME_ONLY build."]
pub const AV1E_SET_ALLOW_WARPED_MOTION: aome_enc_control_id = 97;
#[doc = "Codec control function to turn on / off filter intra usage at\n sequence level, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_FILTER_INTRA: aome_enc_control_id = 98;
#[doc = "Codec control function to turn on / off smooth intra modes usage,\n int parameter\n\n This will enable or disable usage of smooth, smooth_h and smooth_v intra\n modes.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_SMOOTH_INTRA: aome_enc_control_id = 99;
#[doc = "Codec control function to turn on / off Paeth intra mode usage, int\n parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_PAETH_INTRA: aome_enc_control_id = 100;
#[doc = "Codec control function to turn on / off CFL uv intra mode usage, int\n parameter\n\n This will enable or disable usage of chroma-from-luma intra mode.\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_CFL_INTRA: aome_enc_control_id = 101;
#[doc = "Codec control function to turn on / off frame superresolution, int\n parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_SUPERRES: aome_enc_control_id = 102;
#[doc = "Codec control function to turn on / off overlay frames for\n filtered ALTREF frames, int parameter\n\n This will enable or disable coding of overlay frames for filtered ALTREF\n frames. When set to 0, overlay frames are not used but show existing frame\n is used to display the filtered ALTREF frame as is. As a result the decoded\n frame rate remains the same as the display frame rate. The default is 1."]
pub const AV1E_SET_ENABLE_OVERLAY: aome_enc_control_id = 103;
#[doc = "Codec control function to turn on/off palette mode, int parameter"]
pub const AV1E_SET_ENABLE_PALETTE: aome_enc_control_id = 104;
#[doc = "Codec control function to turn on/off intra block copy mode, int\nparameter"]
pub const AV1E_SET_ENABLE_INTRABC: aome_enc_control_id = 105;
#[doc = "Codec control function to turn on/off intra angle delta, int\nparameter"]
pub const AV1E_SET_ENABLE_ANGLE_DELTA: aome_enc_control_id = 106;
#[doc = "Codec control function to set the delta q mode, unsigned int\n parameter\n\n AV1 supports a delta q mode feature, that allows modulating q per\n superblock.\n\n - 0 = deltaq signaling off\n - 1 = use modulation to maximize objective quality (default)\n - 2 = use modulation for local test\n - 3 = use modulation for key frame perceptual quality optimization\n - 4 = use modulation for user rating based perceptual quality optimization"]
pub const AV1E_SET_DELTAQ_MODE: aome_enc_control_id = 107;
#[doc = "Codec control function to turn on/off loopfilter modulation\n when delta q modulation is enabled, unsigned int parameter.\n\n \\attention AV1 only supports loopfilter modulation when delta q\n modulation is enabled as well."]
pub const AV1E_SET_DELTALF_MODE: aome_enc_control_id = 108;
#[doc = "Codec control function to set the single tile decoding mode,\n unsigned int parameter\n\n \\attention Only applicable if large scale tiling is on.\n\n - 0 = single tile decoding is off\n - 1 = single tile decoding is on (default)"]
pub const AV1E_SET_SINGLE_TILE_DECODING: aome_enc_control_id = 109;
#[doc = "Codec control function to enable the extreme motion vector unit\n test, unsigned int parameter\n\n - 0 = off\n - 1 = MAX_EXTREME_MV\n - 2 = MIN_EXTREME_MV\n\n \\note This is only used in motion vector unit test."]
pub const AV1E_ENABLE_MOTION_VECTOR_UNIT_TEST: aome_enc_control_id = 110;
#[doc = "Codec control function to signal picture timing info in the\n bitstream, aom_timing_info_type_t parameter. Default is\n AOM_TIMING_UNSPECIFIED."]
pub const AV1E_SET_TIMING_INFO_TYPE: aome_enc_control_id = 111;
#[doc = "Codec control function to add film grain parameters (one of several\n preset types) info in the bitstream, int parameter\n\nValid range: 0..16, 0 is unknown, 1..16 are test vectors"]
pub const AV1E_SET_FILM_GRAIN_TEST_VECTOR: aome_enc_control_id = 112;
#[doc = "Codec control function to set the path to the film grain parameters,\n const char* parameter"]
pub const AV1E_SET_FILM_GRAIN_TABLE: aome_enc_control_id = 113;
#[doc = "Sets the noise level, int parameter"]
pub const AV1E_SET_DENOISE_NOISE_LEVEL: aome_enc_control_id = 114;
#[doc = "Sets the denoisers block size, unsigned int parameter"]
pub const AV1E_SET_DENOISE_BLOCK_SIZE: aome_enc_control_id = 115;
#[doc = "Sets the chroma subsampling x value, unsigned int parameter"]
pub const AV1E_SET_CHROMA_SUBSAMPLING_X: aome_enc_control_id = 116;
#[doc = "Sets the chroma subsampling y value, unsigned int parameter"]
pub const AV1E_SET_CHROMA_SUBSAMPLING_Y: aome_enc_control_id = 117;
#[doc = "Control to use a reduced tx type set, int parameter"]
pub const AV1E_SET_REDUCED_TX_TYPE_SET: aome_enc_control_id = 118;
#[doc = "Control to use dct only for intra modes, int parameter"]
pub const AV1E_SET_INTRA_DCT_ONLY: aome_enc_control_id = 119;
#[doc = "Control to use dct only for inter modes, int parameter"]
pub const AV1E_SET_INTER_DCT_ONLY: aome_enc_control_id = 120;
#[doc = "Control to use default tx type only for intra modes, int parameter"]
pub const AV1E_SET_INTRA_DEFAULT_TX_ONLY: aome_enc_control_id = 121;
#[doc = "Control to use adaptive quantize_b, int parameter"]
pub const AV1E_SET_QUANT_B_ADAPT: aome_enc_control_id = 122;
#[doc = "Control to select maximum height for the GF group pyramid structure,\n unsigned int parameter\n\n Valid range: 0..5"]
pub const AV1E_SET_GF_MAX_PYRAMID_HEIGHT: aome_enc_control_id = 123;
#[doc = "Control to select maximum reference frames allowed per frame, int\n parameter\n\n Valid range: 3..7"]
pub const AV1E_SET_MAX_REFERENCE_FRAMES: aome_enc_control_id = 124;
#[doc = "Control to use reduced set of single and compound references, int\nparameter"]
pub const AV1E_SET_REDUCED_REFERENCE_SET: aome_enc_control_id = 125;
#[doc = "Control to set frequency of the cost updates for coefficients,\n unsigned int parameter\n\n - 0 = update at SB level (default)\n - 1 = update at SB row level in tile\n - 2 = update at tile level\n - 3 = turn off"]
pub const AV1E_SET_COEFF_COST_UPD_FREQ: aome_enc_control_id = 126;
#[doc = "Control to set frequency of the cost updates for mode, unsigned int\n parameter\n\n - 0 = update at SB level (default)\n - 1 = update at SB row level in tile\n - 2 = update at tile level\n - 3 = turn off"]
pub const AV1E_SET_MODE_COST_UPD_FREQ: aome_enc_control_id = 127;
#[doc = "Control to set frequency of the cost updates for motion vectors,\n unsigned int parameter\n\n - 0 = update at SB level (default)\n - 1 = update at SB row level in tile\n - 2 = update at tile level\n - 3 = turn off"]
pub const AV1E_SET_MV_COST_UPD_FREQ: aome_enc_control_id = 128;
#[doc = "Control to set bit mask that specifies which tier each of the 32\n possible operating points conforms to, unsigned int parameter\n\n - 0 = main tier (default)\n - 1 = high tier"]
pub const AV1E_SET_TIER_MASK: aome_enc_control_id = 129;
#[doc = "Control to set minimum compression ratio, unsigned int parameter\n Take integer values. If non-zero, encoder will try to keep the compression\n ratio of each frame to be higher than the given value divided by 100.\n E.g. 850 means minimum compression ratio of 8.5."]
pub const AV1E_SET_MIN_CR: aome_enc_control_id = 130;
#[doc = "Codec control function to set the layer id, aom_svc_layer_id_t*\n parameter"]
pub const AV1E_SET_SVC_LAYER_ID: aome_enc_control_id = 131;
#[doc = "Codec control function to set SVC parameters, aom_svc_params_t*\n parameter"]
pub const AV1E_SET_SVC_PARAMS: aome_enc_control_id = 132;
#[doc = "Codec control function to set reference frame config:\n the ref_idx and the refresh flags for each buffer slot.\n aom_svc_ref_frame_config_t* parameter"]
pub const AV1E_SET_SVC_REF_FRAME_CONFIG: aome_enc_control_id = 133;
#[doc = "Codec control function to set the path to the VMAF model used when\n tuning the encoder for VMAF, const char* parameter"]
pub const AV1E_SET_VMAF_MODEL_PATH: aome_enc_control_id = 134;
#[doc = "Codec control function to enable EXT_TILE_DEBUG in AV1 encoder,\n unsigned int parameter\n\n - 0 = disable (default)\n - 1 = enable\n\n \\note This is only used in lightfield example test."]
pub const AV1E_ENABLE_EXT_TILE_DEBUG: aome_enc_control_id = 135;
#[doc = "Codec control function to enable the superblock multipass unit test\n in AV1 to ensure that the encoder does not leak state between different\n passes. unsigned int parameter.\n\n - 0 = disable (default)\n - 1 = enable\n\n \\note This is only used in sb_multipass unit test."]
pub const AV1E_ENABLE_SB_MULTIPASS_UNIT_TEST: aome_enc_control_id = 136;
#[doc = "Control to select minimum height for the GF group pyramid structure,\n unsigned int parameter\n\n Valid values: 0..5"]
pub const AV1E_SET_GF_MIN_PYRAMID_HEIGHT: aome_enc_control_id = 137;
#[doc = "Control to set average complexity of the corpus in the case of\n single pass vbr based on LAP, unsigned int parameter"]
pub const AV1E_SET_VBR_CORPUS_COMPLEXITY_LAP: aome_enc_control_id = 138;
#[doc = "Control to get baseline gf interval"]
pub const AV1E_GET_BASELINE_GF_INTERVAL: aome_enc_control_id = 139;
#[doc = "Control to get baseline gf interval"]
pub const AV1E_SET_ENABLE_DNL_DENOISING: aome_enc_control_id = 140;
#[doc = "Codec control function to turn on / off D45 to D203 intra mode\n usage, int parameter\n\n This will enable or disable usage of D45 to D203 intra modes, which are a\n subset of directional modes. This control has no effect if directional\n modes are disabled (AV1E_SET_ENABLE_DIRECTIONAL_INTRA set to 0).\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_DIAGONAL_INTRA: aome_enc_control_id = 141;
#[doc = "Control to set frequency of the cost updates for intrabc motion\n vectors, unsigned int parameter\n\n - 0 = update at SB level (default)\n - 1 = update at SB row level in tile\n - 2 = update at tile level\n - 3 = turn off"]
pub const AV1E_SET_DV_COST_UPD_FREQ: aome_enc_control_id = 142;
#[doc = "Codec control to set the path for partition stats read and write.\n const char * parameter."]
pub const AV1E_SET_PARTITION_INFO_PATH: aome_enc_control_id = 143;
#[doc = "Codec control to use an external partition model\n A set of callback functions is passed through this control\n to let the encoder encode with given partitions."]
pub const AV1E_SET_EXTERNAL_PARTITION: aome_enc_control_id = 144;
#[doc = "Codec control function to turn on / off directional intra mode\n usage, int parameter\n\n - 0 = disable\n - 1 = enable (default)"]
pub const AV1E_SET_ENABLE_DIRECTIONAL_INTRA: aome_enc_control_id = 145;
#[doc = "Control to turn on / off transform size search.\n Note: it can not work with non RD pick mode in real-time encoding,\n where the max transform size is only 16x16.\n It will be ignored if non RD pick mode is set.\n\n - 0 = disable, transforms always have the largest possible size\n - 1 = enable, search for the best transform size for each block (default)"]
pub const AV1E_SET_ENABLE_TX_SIZE_SEARCH: aome_enc_control_id = 146;
#[doc = "Codec control function to set reference frame compound prediction.\n aom_svc_ref_frame_comp_pred_t* parameter"]
pub const AV1E_SET_SVC_REF_FRAME_COMP_PRED: aome_enc_control_id = 147;
#[doc = "Set --deltaq-mode strength.\n\n Valid range: [0, 1000]"]
pub const AV1E_SET_DELTAQ_STRENGTH: aome_enc_control_id = 148;
#[doc = "Codec control to control loop filter\n\n - 0 = Loop filter is disabled for all frames\n - 1 = Loop filter is enabled for all frames\n - 2 = Loop filter is disabled for non-reference frames\n - 3 = Loop filter is disabled for the frames with low motion"]
pub const AV1E_SET_LOOPFILTER_CONTROL: aome_enc_control_id = 149;
#[doc = "Codec control function to get the loopfilter chosen by the encoder,\n int* parameter"]
pub const AOME_GET_LOOPFILTER_LEVEL: aome_enc_control_id = 150;
#[doc = "Codec control to automatically turn off several intra coding tools,\n unsigned int parameter\n - 0 = do not use the feature\n - 1 = enable the automatic decision to turn off several intra tools"]
pub const AV1E_SET_AUTO_INTRA_TOOLS_OFF: aome_enc_control_id = 151;
#[doc = "Codec control function to set flag for rate control used by external\n encoders.\n - 1 = Enable rate control for external encoders. This will disable content\n dependency in rate control and cyclic refresh.\n - 0 = Default. Disable rate control for external encoders."]
pub const AV1E_SET_RTC_EXTERNAL_RC: aome_enc_control_id = 152;
#[doc = "Codec control function to enable frame parallel multi-threading\n of the encoder, unsigned int parameter\n\n - 0 = disable (default)\n - 1 = enable"]
pub const AV1E_SET_FP_MT: aome_enc_control_id = 153;
#[doc = "Codec control to enable actual frame parallel encode or\n simulation of frame parallel encode in FPMT unit test, unsigned int\n parameter\n\n - 0 = simulate frame parallel encode\n - 1 = actual frame parallel encode (default)\n\n \\note This is only used in FPMT unit test."]
pub const AV1E_SET_FP_MT_UNIT_TEST: aome_enc_control_id = 154;
#[doc = "Codec control function to get the target sequence level index for\n each operating point. int* parameter. There can be at most 32 operating\n points. The results will be written into a provided integer array of\n sufficient size. If a target level is not set, the result will be 31.\n Please refer to https://aomediacodec.github.io/av1-spec/#levels for more\n details on level definitions and indices."]
pub const AV1E_GET_TARGET_SEQ_LEVEL_IDX: aome_enc_control_id = 155;
#[doc = "Codec control function to get the number of operating points. int*\n parameter."]
pub const AV1E_GET_NUM_OPERATING_POINTS: aome_enc_control_id = 156;
#[doc = "Codec control function to skip the application of post-processing\n filters on reconstructed frame, unsigned int parameter\n\n - 0 = disable (default)\n - 1 = enable\n\n \\attention For this value to be used aom_codec_enc_cfg_t::g_usage\n            must be set to AOM_USAGE_ALL_INTRA."]
pub const AV1E_SET_SKIP_POSTPROC_FILTERING: aome_enc_control_id = 157;
#[doc = "Codec control function to enable the superblock level\n qp sweep in AV1 to ensure that end-to-end test runs well,\n unsigned int parameter.\n\n - 0 = disable (default)\n - 1 = enable\n\n \\note This is only used in sb_qp_sweep unit test."]
pub const AV1E_ENABLE_SB_QP_SWEEP: aome_enc_control_id = 158;
#[doc = "Codec control to set quantizer for the next frame, int parameter.\n\n - Valid range [0, 63]\n\n This will turn off cyclic refresh. Only applicable to 1-pass."]
pub const AV1E_SET_QUANTIZER_ONE_PASS: aome_enc_control_id = 159;
#[doc = "Codec control to enable the rate distribution guided delta\n quantization in all intra mode, unsigned int parameter\n\n - 0 = disable (default)\n - 1 = enable\n\n \\attention This feature requires --deltaq-mode=3, also an input file\n            which contains rate distribution for each 16x16 block,\n            passed in by --rate-distribution-info=rate_distribution.txt."]
pub const AV1E_ENABLE_RATE_GUIDE_DELTAQ: aome_enc_control_id = 160;
#[doc = "Codec control to set the input file for rate distribution used\n in all intra mode, const char * parameter\n The input should be the name of a text file, which\n contains (rows x cols) float values separated by space.\n Each float value represent the number of bits for each 16x16 block.\n rows = (frame_height + 15) / 16\n cols = (frame_width + 15) / 16\n\n \\attention This feature requires --enable-rate-guide-deltaq=1."]
pub const AV1E_SET_RATE_DISTRIBUTION_INFO: aome_enc_control_id = 161;
#[doc = "Codec control to get the CDEF strength for Y / luma plane,\n int * parameter.\n Returns an integer array of CDEF_MAX_STRENGTHS elements."]
pub const AV1E_GET_LUMA_CDEF_STRENGTH: aome_enc_control_id = 162;
#[doc = "Codec control to set the target bitrate in kilobits per second,\n unsigned int parameter. For 1 pass CBR mode, single layer encoding.\n This controls replaces the call aom_codec_enc_config_set(&codec, &cfg)\n when only target bitrate is changed, and so is much cheaper as it\n bypasses a lot of unneeded code checks."]
pub const AV1E_SET_BITRATE_ONE_PASS_CBR: aome_enc_control_id = 163;
#[doc = "AVx encoder control functions\n\n This set of macros define the control functions available for AVx\n encoder interface.\n The range of encode control ID is 7-229(max).\n\n \\sa #aom_codec_control(aom_codec_ctx_t *ctx, int ctrl_id, ...)"]
pub type aome_enc_control_id = ::std::os::raw::c_uint;
pub const AOME_NORMAL: aom_scaling_mode_1d = 0;
pub const AOME_FOURFIVE: aom_scaling_mode_1d = 1;
pub const AOME_THREEFIVE: aom_scaling_mode_1d = 2;
pub const AOME_THREEFOUR: aom_scaling_mode_1d = 3;
pub const AOME_ONEFOUR: aom_scaling_mode_1d = 4;
pub const AOME_ONEEIGHT: aom_scaling_mode_1d = 5;
pub const AOME_ONETWO: aom_scaling_mode_1d = 6;
pub const AOME_TWOTHREE: aom_scaling_mode_1d = 7;
pub const AOME_ONETHREE: aom_scaling_mode_1d = 8;
#[doc = "aom 1-D scaling mode\n\n This set of constants define 1-D aom scaling modes"]
pub type aom_scaling_mode_1d = ::std::os::raw::c_uint;
#[doc = "aom 1-D scaling mode\n\n This set of constants define 1-D aom scaling modes"]
pub use self::aom_scaling_mode_1d as AOM_SCALING_MODE;
#[doc = " aom region of interest map\n\n These defines the data structures for the region of interest map\n\n TODO(yaowu): create a unit test for ROI map related APIs\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_roi_map {
    #[doc = " An id between 0 and 7 for each 8x8 region within a frame."]
    pub roi_map: *mut ::std::os::raw::c_uchar,
    #[doc = "Number of rows."]
    pub rows: ::std::os::raw::c_uint,
    #[doc = "Number of columns."]
    pub cols: ::std::os::raw::c_uint,
    #[doc = "Quantizer deltas."]
    pub delta_q: [::std::os::raw::c_int; 8usize],
    #[doc = "Loop filter deltas."]
    pub delta_lf: [::std::os::raw::c_int; 8usize],
    #[doc = " Static breakout threshold for each segment."]
    pub static_threshold: [::std::os::raw::c_uint; 8usize],
}
#[doc = " aom region of interest map\n\n These defines the data structures for the region of interest map\n\n TODO(yaowu): create a unit test for ROI map related APIs\n"]
pub type aom_roi_map_t = aom_roi_map;
#[doc = " aom active region map\n\n These defines the data structures for active region map\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_active_map {
    #[doc = "specify an on (1) or off (0) each 16x16 region within a frame"]
    pub active_map: *mut ::std::os::raw::c_uchar,
    #[doc = "number of rows"]
    pub rows: ::std::os::raw::c_uint,
    #[doc = "number of cols"]
    pub cols: ::std::os::raw::c_uint,
}
#[doc = " aom active region map\n\n These defines the data structures for active region map\n"]
pub type aom_active_map_t = aom_active_map;
#[doc = " aom image scaling mode\n\n This defines the data structure for image scaling mode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_scaling_mode {
    #[doc = "horizontal scaling mode"]
    pub h_scaling_mode: AOM_SCALING_MODE,
    #[doc = "vertical scaling mode"]
    pub v_scaling_mode: AOM_SCALING_MODE,
}
#[doc = " aom image scaling mode\n\n This defines the data structure for image scaling mode\n"]
pub type aom_scaling_mode_t = aom_scaling_mode;
pub const AOM_CONTENT_DEFAULT: aom_tune_content = 0;
pub const AOM_CONTENT_SCREEN: aom_tune_content = 1;
pub const AOM_CONTENT_FILM: aom_tune_content = 2;
pub const AOM_CONTENT_INVALID: aom_tune_content = 3;
#[doc = "brief AV1 encoder content type"]
pub type aom_tune_content = ::std::os::raw::c_uint;
pub const AOM_TIMING_UNSPECIFIED: aom_timing_info_type_t = 0;
pub const AOM_TIMING_EQUAL: aom_timing_info_type_t = 1;
pub const AOM_TIMING_DEC_MODEL: aom_timing_info_type_t = 2;
#[doc = "brief AV1 encoder timing info type signaling"]
pub type aom_timing_info_type_t = ::std::os::raw::c_uint;
pub const AOM_TUNE_PSNR: aom_tune_metric = 0;
pub const AOM_TUNE_SSIM: aom_tune_metric = 1;
pub const AOM_TUNE_VMAF_WITH_PREPROCESSING: aom_tune_metric = 4;
pub const AOM_TUNE_VMAF_WITHOUT_PREPROCESSING: aom_tune_metric = 5;
pub const AOM_TUNE_VMAF_MAX_GAIN: aom_tune_metric = 6;
pub const AOM_TUNE_VMAF_NEG_MAX_GAIN: aom_tune_metric = 7;
pub const AOM_TUNE_BUTTERAUGLI: aom_tune_metric = 8;
pub const AOM_TUNE_VMAF_SALIENCY_MAP: aom_tune_metric = 9;
#[doc = "Model tuning parameters\n\n Changes the encoder to tune for certain types of input material.\n"]
pub type aom_tune_metric = ::std::os::raw::c_uint;
pub const AOM_DIST_METRIC_PSNR: aom_dist_metric = 0;
pub const AOM_DIST_METRIC_QM_PSNR: aom_dist_metric = 1;
#[doc = "Distortion metric to use for RD optimization.\n\n Changes the encoder to use a different distortion metric for RD search. Note\n that this value operates on a \"lower level\" compared to aom_tune_metric - it\n affects the distortion metric inside a block, while aom_tune_metric only\n affects RD across blocks.\n"]
pub type aom_dist_metric = ::std::os::raw::c_uint;
#[doc = "brief Struct for spatial and temporal layer ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_layer_id {
    #[doc = "Spatial layer ID"]
    pub spatial_layer_id: ::std::os::raw::c_int,
    #[doc = "Temporal layer ID"]
    pub temporal_layer_id: ::std::os::raw::c_int,
}
#[doc = "brief Struct for spatial and temporal layer ID"]
pub type aom_svc_layer_id_t = aom_svc_layer_id;
#[doc = "brief Parameter type for SVC\n\n In the arrays of size AOM_MAX_LAYERS, the index for spatial layer `sl` and\n temporal layer `tl` is sl * number_temporal_layers + tl.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_params {
    #[doc = "Number of spatial layers"]
    pub number_spatial_layers: ::std::os::raw::c_int,
    #[doc = "Number of temporal layers"]
    pub number_temporal_layers: ::std::os::raw::c_int,
    #[doc = "Max Q for each layer"]
    pub max_quantizers: [::std::os::raw::c_int; 32usize],
    #[doc = "Min Q for each layer"]
    pub min_quantizers: [::std::os::raw::c_int; 32usize],
    #[doc = "Scaling factor-numerator"]
    pub scaling_factor_num: [::std::os::raw::c_int; 4usize],
    #[doc = "Scaling factor-denominator"]
    pub scaling_factor_den: [::std::os::raw::c_int; 4usize],
    #[doc = " Target bitrate for each layer, in kilobits per second"]
    pub layer_target_bitrate: [::std::os::raw::c_int; 32usize],
    #[doc = " Frame rate factor for each temporal layer"]
    pub framerate_factor: [::std::os::raw::c_int; 8usize],
}
#[doc = "brief Parameter type for SVC\n\n In the arrays of size AOM_MAX_LAYERS, the index for spatial layer `sl` and\n temporal layer `tl` is sl * number_temporal_layers + tl.\n"]
pub type aom_svc_params_t = aom_svc_params;
#[doc = "brief Parameters for setting ref frame config"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_ref_frame_config {
    #[doc = "Reference flag for each of the 7 references."]
    pub reference: [::std::os::raw::c_int; 7usize],
    #[doc = " Buffer slot index for each of 7 references."]
    pub ref_idx: [::std::os::raw::c_int; 7usize],
    #[doc = "Refresh flag for each of the 8 slots."]
    pub refresh: [::std::os::raw::c_int; 8usize],
}
#[doc = "brief Parameters for setting ref frame config"]
pub type aom_svc_ref_frame_config_t = aom_svc_ref_frame_config;
#[doc = "brief Parameters for setting ref frame compound prediction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_ref_frame_comp_pred {
    #[doc = "<Compound reference flag."]
    pub use_comp_pred: [::std::os::raw::c_int; 3usize],
}
#[doc = "brief Parameters for setting ref frame compound prediction"]
pub type aom_svc_ref_frame_comp_pred_t = aom_svc_ref_frame_comp_pred;
pub type aom_codec_control_type_AOME_USE_REFERENCE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_ROI_MAP = *mut aom_roi_map_t;
pub type aom_codec_control_type_AOME_SET_ACTIVEMAP = *mut aom_active_map_t;
pub type aom_codec_control_type_AOME_SET_SCALEMODE = *mut aom_scaling_mode_t;
pub type aom_codec_control_type_AOME_SET_SPATIAL_LAYER_ID = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_CPUUSED = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_ENABLEAUTOALTREF = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_SHARPNESS = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_STATIC_THRESHOLD = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_GET_LAST_QUANTIZER = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_GET_LAST_QUANTIZER_64 = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_ARNR_MAXFRAMES = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_ARNR_STRENGTH = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_TUNING = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_CQ_LEVEL = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_MAX_INTRA_BITRATE_PCT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_NUMBER_SPATIAL_LAYERS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_SET_MAX_INTER_BITRATE_PCT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_GF_CBR_BOOST_PCT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_LOSSLESS = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ROW_MT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_TILE_COLUMNS = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_TILE_ROWS = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_TPL_MODEL = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_KEYFRAME_FILTERING = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_FRAME_PARALLEL_DECODING = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ERROR_RESILIENT_MODE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_S_FRAME_MODE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_AQ_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_FRAME_PERIODIC_BOOST = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_NOISE_SENSITIVITY = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_TUNE_CONTENT = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_CDF_UPDATE_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_COLOR_PRIMARIES = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_TRANSFER_CHARACTERISTICS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_MATRIX_COEFFICIENTS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_CHROMA_SAMPLE_POSITION = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_MIN_GF_INTERVAL = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MAX_GF_INTERVAL = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_GET_ACTIVEMAP = *mut aom_active_map_t;
pub type aom_codec_control_type_AV1E_SET_COLOR_RANGE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_RENDER_SIZE = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_TARGET_SEQ_LEVEL_IDX = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_GET_SEQ_LEVEL_IDX = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_SUPERBLOCK_SIZE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOME_SET_ENABLEAUTOBWDREF = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_CDEF = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_RESTORATION = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_FORCE_VIDEO_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_OBMC = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_DISABLE_TRELLIS_QUANT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_QM = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DIST_8X8 = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QM_MIN = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QM_MAX = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QM_Y = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QM_U = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QM_V = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_NUM_TG = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MTU = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_ENABLE_RECT_PARTITIONS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_AB_PARTITIONS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_1TO4_PARTITIONS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_MIN_PARTITION_SIZE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_MAX_PARTITION_SIZE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_INTRA_EDGE_FILTER = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_ORDER_HINT = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_TX64 = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_FLIP_IDTX = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_RECT_TX = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DIST_WTD_COMP = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_REF_FRAME_MVS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ALLOW_REF_FRAME_MVS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DUAL_FILTER = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_CHROMA_DELTAQ = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_MASKED_COMP = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_ONESIDED_COMP = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_INTERINTRA_COMP = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_SMOOTH_INTERINTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DIFF_WTD_COMP = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_INTERINTER_WEDGE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_INTERINTRA_WEDGE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_GLOBAL_MOTION = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_WARPED_MOTION = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ALLOW_WARPED_MOTION = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_FILTER_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_SMOOTH_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_PAETH_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_CFL_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_SUPERRES = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_OVERLAY = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_PALETTE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_INTRABC = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_ANGLE_DELTA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_DELTAQ_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_DELTALF_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_SINGLE_TILE_DECODING = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_ENABLE_MOTION_VECTOR_UNIT_TEST = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_TIMING_INFO_TYPE = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_FILM_GRAIN_TEST_VECTOR = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_FILM_GRAIN_TABLE = *const ::std::os::raw::c_char;
pub type aom_codec_control_type_AV1E_SET_DENOISE_NOISE_LEVEL = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_DENOISE_BLOCK_SIZE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_CHROMA_SUBSAMPLING_X = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_CHROMA_SUBSAMPLING_Y = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_REDUCED_TX_TYPE_SET = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_INTRA_DCT_ONLY = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_INTER_DCT_ONLY = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_INTRA_DEFAULT_TX_ONLY = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_QUANT_B_ADAPT = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_GF_MAX_PYRAMID_HEIGHT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MAX_REFERENCE_FRAMES = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_REDUCED_REFERENCE_SET = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_COEFF_COST_UPD_FREQ = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MODE_COST_UPD_FREQ = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MV_COST_UPD_FREQ = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_TIER_MASK = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_MIN_CR = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_SVC_LAYER_ID = *mut aom_svc_layer_id_t;
pub type aom_codec_control_type_AV1E_SET_SVC_PARAMS = *mut aom_svc_params_t;
pub type aom_codec_control_type_AV1E_SET_SVC_REF_FRAME_CONFIG = *mut aom_svc_ref_frame_config_t;
pub type aom_codec_control_type_AV1E_SET_VMAF_MODEL_PATH = *const ::std::os::raw::c_char;
pub type aom_codec_control_type_AV1E_ENABLE_EXT_TILE_DEBUG = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_ENABLE_SB_MULTIPASS_UNIT_TEST = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_GF_MIN_PYRAMID_HEIGHT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_VBR_CORPUS_COMPLEXITY_LAP = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_GET_BASELINE_GF_INTERVAL = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DNL_DENOISING = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DIAGONAL_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_DV_COST_UPD_FREQ = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_PARTITION_INFO_PATH = *const ::std::os::raw::c_char;
pub type aom_codec_control_type_AV1E_SET_EXTERNAL_PARTITION = *mut aom_ext_part_funcs_t;
pub type aom_codec_control_type_AV1E_SET_ENABLE_DIRECTIONAL_INTRA = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_ENABLE_TX_SIZE_SEARCH = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_SVC_REF_FRAME_COMP_PRED =
    *mut aom_svc_ref_frame_comp_pred_t;
pub type aom_codec_control_type_AV1E_SET_DELTAQ_STRENGTH = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_LOOPFILTER_CONTROL = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOME_GET_LOOPFILTER_LEVEL = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_AUTO_INTRA_TOOLS_OFF = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_RTC_EXTERNAL_RC = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_FP_MT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_FP_MT_UNIT_TEST = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_GET_TARGET_SEQ_LEVEL_IDX = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_GET_NUM_OPERATING_POINTS = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_SKIP_POSTPROC_FILTERING = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_ENABLE_SB_QP_SWEEP = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_QUANTIZER_ONE_PASS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_ENABLE_RATE_GUIDE_DELTAQ = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1E_SET_RATE_DISTRIBUTION_INFO = *const ::std::os::raw::c_char;
pub type aom_codec_control_type_AV1E_GET_LUMA_CDEF_STRENGTH = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1E_SET_BITRATE_ONE_PASS_CBR = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "A single instance of the AV1 decoder.\n\\deprecated This access mechanism is provided for backwards compatibility;\n prefer aom_codec_av1_dx()."]
    pub static mut aom_codec_av1_dx_algo: aom_codec_iface_t;
}
extern "C" {
    #[doc = "The interface to the AV1 decoder."]
    pub fn aom_codec_av1_dx() -> *const aom_codec_iface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Accounting {
    _unused: [u8; 0],
}
#[doc = " Callback that inspects decoder frame data."]
pub type aom_inspect_cb = ::std::option::Option<
    unsafe extern "C" fn(decoder: *mut ::std::os::raw::c_void, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = "Structure to hold inspection callback and context.\n\n Defines a structure to hold the inspection callback function and calling\n context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_inspect_init {
    #[doc = " Inspection callback."]
    pub inspect_cb: aom_inspect_cb,
    #[doc = " Inspection context."]
    pub inspect_ctx: *mut ::std::os::raw::c_void,
}
#[doc = "Structure to hold a tile's start address and size in the bitstream.\n\n Defines a structure to hold a tile's start address and size in the bitstream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_tile_data {
    #[doc = " Tile data size."]
    pub coded_tile_data_size: usize,
    #[doc = " Tile's start address."]
    pub coded_tile_data: *const ::std::os::raw::c_void,
    #[doc = " Extra size information."]
    pub extra_size: usize,
}
#[doc = "Structure to hold information about tiles in a frame.\n\n Defines a structure to hold a frame's tile information, namely\n number of tile columns, number of tile_rows, and the width and\n height of each tile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_tile_info {
    #[doc = " Indicates the number of tile columns."]
    pub tile_columns: ::std::os::raw::c_int,
    #[doc = " Indicates the number of tile rows."]
    pub tile_rows: ::std::os::raw::c_int,
    #[doc = " Indicates the tile widths in units of SB."]
    pub tile_widths: [::std::os::raw::c_int; 64usize],
    #[doc = " Indicates the tile heights in units of SB."]
    pub tile_heights: [::std::os::raw::c_int; 64usize],
    #[doc = " Indicates the number of tile groups present in a frame."]
    pub num_tile_groups: ::std::os::raw::c_int,
}
#[doc = "Structure to hold information about still image coding.\n\n Defines a structure to hold a information regarding still picture\n and its header type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_still_picture_info {
    #[doc = " Video is a single frame still picture"]
    pub is_still_picture: ::std::os::raw::c_int,
    #[doc = " Use full header for still picture"]
    pub is_reduced_still_picture_hdr: ::std::os::raw::c_int,
}
#[doc = "Structure to hold information about S_FRAME.\n\n Defines a structure to hold a information regarding S_FRAME\n and its position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_s_frame_info {
    #[doc = " Indicates if current frame is S_FRAME"]
    pub is_s_frame: ::std::os::raw::c_int,
    #[doc = " Indicates if current S_FRAME is present at ALTREF frame"]
    pub is_s_frame_at_altref: ::std::os::raw::c_int,
}
#[doc = "Structure to hold information about screen content tools.\n\n Defines a structure to hold information about screen content\n tools, namely: allow_screen_content_tools, allow_intrabc, and\n force_integer_mv."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_screen_content_tools_info {
    #[doc = " Are screen content tools allowed"]
    pub allow_screen_content_tools: ::std::os::raw::c_int,
    #[doc = " Is intrabc allowed"]
    pub allow_intrabc: ::std::os::raw::c_int,
    #[doc = " Is integer mv forced"]
    pub force_integer_mv: ::std::os::raw::c_int,
}
#[doc = "Structure to hold the external reference frame pointer.\n\n Define a structure to hold the external reference frame pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct av1_ext_ref_frame {
    #[doc = " Start pointer of external references."]
    pub img: *mut aom_image_t,
    #[doc = " Number of available external references."]
    pub num: ::std::os::raw::c_int,
}
#[doc = "Structure to hold the external reference frame pointer.\n\n Define a structure to hold the external reference frame pointer."]
pub type av1_ext_ref_frame_t = av1_ext_ref_frame;
#[doc = "Codec control function to get info on which reference frames were\n updated by the last decode, int* parameter"]
pub const AOMD_GET_LAST_REF_UPDATES: aom_dec_control_id = 256;
#[doc = "Codec control function to check if the indicated frame is\ncorrupted, int* parameter"]
pub const AOMD_GET_FRAME_CORRUPTED: aom_dec_control_id = 257;
#[doc = "Codec control function to get info on which reference frames were\n used by the last decode, int* parameter"]
pub const AOMD_GET_LAST_REF_USED: aom_dec_control_id = 258;
#[doc = "Codec control function to get the dimensions that the current\n frame is decoded at, int* parameter\n\n This may be different to the intended display size for the frame as\n specified in the wrapper or frame header (see AV1D_GET_DISPLAY_SIZE)."]
pub const AV1D_GET_FRAME_SIZE: aom_dec_control_id = 259;
#[doc = "Codec control function to get the current frame's intended display\n dimensions (as specified in the wrapper or frame header), int* parameter\n\n This may be different to the decoded dimensions of this frame (see\n AV1D_GET_FRAME_SIZE)."]
pub const AV1D_GET_DISPLAY_SIZE: aom_dec_control_id = 260;
#[doc = "Codec control function to get the bit depth of the stream,\n unsigned int* parameter"]
pub const AV1D_GET_BIT_DEPTH: aom_dec_control_id = 261;
#[doc = "Codec control function to get the image format of the stream,\n aom_img_fmt_t* parameter"]
pub const AV1D_GET_IMG_FORMAT: aom_dec_control_id = 262;
#[doc = "Codec control function to get the size of the tile, unsigned int*\n parameter"]
pub const AV1D_GET_TILE_SIZE: aom_dec_control_id = 263;
#[doc = "Codec control function to get the tile count in a tile list,\n unsigned int* parameter"]
pub const AV1D_GET_TILE_COUNT: aom_dec_control_id = 264;
#[doc = "Codec control function to set the byte alignment of the planes in\n the reference buffers, int parameter\n\n Valid values are power of 2, from 32 to 1024. A value of 0 sets\n legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly\n follows Y plane, and V plane directly follows U plane. Default value is 0."]
pub const AV1_SET_BYTE_ALIGNMENT: aom_dec_control_id = 265;
#[doc = "Codec control function to invert the decoding order to from right to\n left, int parameter\n\n The function is used in a test to confirm the decoding independence of tile\n columns. The function may be used in application where this order\n of decoding is desired. int parameter\n\n TODO(yaowu): Rework the unit test that uses this control, and in a future\n              release, this test-only control shall be removed."]
pub const AV1_INVERT_TILE_DECODE_ORDER: aom_dec_control_id = 266;
#[doc = "Codec control function to set the skip loop filter flag, int\n parameter\n\n Valid values are integers. The decoder will skip the loop filter\n when its value is set to nonzero. If the loop filter is skipped the\n decoder may accumulate decode artifacts. The default value is 0."]
pub const AV1_SET_SKIP_LOOP_FILTER: aom_dec_control_id = 267;
#[doc = "Codec control function to retrieve a pointer to the Accounting\n struct, takes Accounting** as parameter\n\n If called before a frame has been decoded, this returns AOM_CODEC_ERROR.\n The caller should ensure that AOM_CODEC_OK is returned before attempting\n to dereference the Accounting pointer.\n\n \\attention When configured with -DCONFIG_ACCOUNTING=0, the default, this\n returns AOM_CODEC_INCAPABLE."]
pub const AV1_GET_ACCOUNTING: aom_dec_control_id = 268;
#[doc = "Codec control function to get last decoded frame quantizer,\n int* parameter\n\n Returned value uses internal quantizer scale defined by the codec."]
pub const AOMD_GET_LAST_QUANTIZER: aom_dec_control_id = 269;
#[doc = "Codec control function to set the range of tile decoding, int\n parameter\n\n A value that is greater and equal to zero indicates only the specific\n row/column is decoded. A value that is -1 indicates the whole row/column\n is decoded. A special case is both values are -1 that means the whole\n frame is decoded."]
pub const AV1_SET_DECODE_TILE_ROW: aom_dec_control_id = 270;
#[doc = "Codec control function to set the range of tile decoding, int\n parameter\n\n A value that is greater and equal to zero indicates only the specific\n row/column is decoded. A value that is -1 indicates the whole row/column\n is decoded. A special case is both values are -1 that means the whole\n frame is decoded."]
pub const AV1_SET_DECODE_TILE_COL: aom_dec_control_id = 271;
#[doc = "Codec control function to set the tile coding mode, unsigned int\n parameter\n\n - 0 = tiles are coded in normal tile mode\n - 1 = tiles are coded in large-scale tile mode"]
pub const AV1_SET_TILE_MODE: aom_dec_control_id = 272;
#[doc = "Codec control function to get the frame header information of an\n encoded frame, aom_tile_data* parameter"]
pub const AV1D_GET_FRAME_HEADER_INFO: aom_dec_control_id = 273;
#[doc = "Codec control function to get the start address and size of a\n tile in the coded bitstream, aom_tile_data* parameter."]
pub const AV1D_GET_TILE_DATA: aom_dec_control_id = 274;
#[doc = "Codec control function to set the external references' pointers in\n the decoder, av1_ext_ref_frame_t* parameter.\n\n This is used while decoding the tile list OBU in large-scale tile coding\n mode."]
pub const AV1D_SET_EXT_REF_PTR: aom_dec_control_id = 275;
#[doc = "Codec control function to enable the ext-tile software debug and\n testing code in the decoder, unsigned int parameter"]
pub const AV1D_EXT_TILE_DEBUG: aom_dec_control_id = 276;
#[doc = "Codec control function to enable the row based multi-threading of\n decoding, unsigned int parameter\n\n - 0 = disabled\n - 1 = enabled (default)"]
pub const AV1D_SET_ROW_MT: aom_dec_control_id = 277;
#[doc = "Codec control function to indicate whether bitstream is in\n Annex-B format, unsigned int parameter"]
pub const AV1D_SET_IS_ANNEXB: aom_dec_control_id = 278;
#[doc = "Codec control function to indicate which operating point to use,\n int parameter\n\n A scalable stream may define multiple operating points, each of which\n defines a set of temporal and spatial layers to be processed. The\n operating point index may take a value between 0 and\n operating_points_cnt_minus_1 (which is at most 31)."]
pub const AV1D_SET_OPERATING_POINT: aom_dec_control_id = 279;
#[doc = "Codec control function to indicate whether to output one frame per\n temporal unit (the default), or one frame per spatial layer, int parameter\n\n In a scalable stream, each temporal unit corresponds to a single \"frame\"\n of video, and within a temporal unit there may be multiple spatial layers\n with different versions of that frame.\n For video playback, only the highest-quality version (within the\n selected operating point) is needed, but for some use cases it is useful\n to have access to multiple versions of a frame when they are available."]
pub const AV1D_SET_OUTPUT_ALL_LAYERS: aom_dec_control_id = 280;
#[doc = "Codec control function to set an aom_inspect_cb callback that is\n invoked each time a frame is decoded, aom_inspect_init* parameter\n\n \\attention When configured with -DCONFIG_INSPECTION=0, the default, this\n returns AOM_CODEC_INCAPABLE."]
pub const AV1_SET_INSPECTION_CALLBACK: aom_dec_control_id = 281;
#[doc = "Codec control function to set the skip film grain flag, int\n parameter\n\n Valid values are integers. The decoder will skip the film grain when its\n value is set to nonzero. The default value is 0."]
pub const AV1D_SET_SKIP_FILM_GRAIN: aom_dec_control_id = 282;
#[doc = "Codec control function to check the presence of forward key frames,\n int* parameter"]
pub const AOMD_GET_FWD_KF_PRESENT: aom_dec_control_id = 283;
#[doc = "Codec control function to get the frame flags of the previous frame\n decoded, int* parameter\n\n This will return a flag of type aom_codec_frame_flags_t."]
pub const AOMD_GET_FRAME_FLAGS: aom_dec_control_id = 284;
#[doc = "Codec control function to check the presence of altref frames, int*\n parameter"]
pub const AOMD_GET_ALTREF_PRESENT: aom_dec_control_id = 285;
#[doc = "Codec control function to get tile information of the previous frame\n decoded, aom_tile_info* parameter\n\n This will return a struct of type aom_tile_info."]
pub const AOMD_GET_TILE_INFO: aom_dec_control_id = 286;
#[doc = "Codec control function to get screen content tools information,\n aom_screen_content_tools_info* parameter\n\n It returns a struct of type aom_screen_content_tools_info, which contains\n the header flags allow_screen_content_tools, allow_intrabc, and\n force_integer_mv."]
pub const AOMD_GET_SCREEN_CONTENT_TOOLS_INFO: aom_dec_control_id = 287;
#[doc = "Codec control function to get the still picture coding information,\n aom_still_picture_info* parameter"]
pub const AOMD_GET_STILL_PICTURE: aom_dec_control_id = 288;
#[doc = "Codec control function to get superblock size,\n aom_superblock_size_t* parameter\n\n It returns an enum, indicating the superblock size read from the sequence\n header(0 for BLOCK_64X64 and 1 for BLOCK_128X128)"]
pub const AOMD_GET_SB_SIZE: aom_dec_control_id = 289;
#[doc = "Codec control function to check if the previous frame\n decoded has show existing frame flag set, int* parameter"]
pub const AOMD_GET_SHOW_EXISTING_FRAME_FLAG: aom_dec_control_id = 290;
#[doc = "Codec control function to get the S_FRAME coding information,\n aom_s_frame_info* parameter"]
pub const AOMD_GET_S_FRAME_INFO: aom_dec_control_id = 291;
#[doc = "Codec control function to get the show frame flag, int* parameter"]
pub const AOMD_GET_SHOW_FRAME_FLAG: aom_dec_control_id = 292;
#[doc = "Codec control function to get the base q index of a frame, int*\n parameter"]
pub const AOMD_GET_BASE_Q_IDX: aom_dec_control_id = 293;
#[doc = "Codec control function to get the order hint of a frame, unsigned\n int* parameter"]
pub const AOMD_GET_ORDER_HINT: aom_dec_control_id = 294;
#[doc = "Codec control function to get the info of a 4x4 block.\n Parameters: int mi_row, int mi_col, and MB_MODE_INFO*.\n\n \\note This only returns a shallow copy, so all pointer members should not\n be used."]
pub const AV1D_GET_MI_INFO: aom_dec_control_id = 295;
#[doc = "\\enum aom_dec_control_id\nAOM decoder control functions\n\n This set of macros define the control functions available for the AOM\n decoder interface.\n The range for decoder control ID is >= 256.\n\n \\sa #aom_codec_control(aom_codec_ctx_t *ctx, int ctrl_id, ...)"]
pub type aom_dec_control_id = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AOMD_GET_LAST_REF_UPDATES = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_FRAME_CORRUPTED = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_LAST_REF_USED = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1D_GET_FRAME_SIZE = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1D_GET_DISPLAY_SIZE = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1D_GET_BIT_DEPTH = *mut ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_GET_IMG_FORMAT = *mut aom_img_fmt_t;
pub type aom_codec_control_type_AV1D_GET_TILE_SIZE = *mut ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_GET_TILE_COUNT = *mut ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1_INVERT_TILE_DECODE_ORDER = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_SET_SKIP_LOOP_FILTER = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_GET_ACCOUNTING = *mut *mut Accounting;
pub type aom_codec_control_type_AOMD_GET_LAST_QUANTIZER = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_SET_DECODE_TILE_ROW = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_SET_DECODE_TILE_COL = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_SET_TILE_MODE = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_GET_FRAME_HEADER_INFO = *mut aom_tile_data;
pub type aom_codec_control_type_AV1D_GET_TILE_DATA = *mut aom_tile_data;
pub type aom_codec_control_type_AV1D_SET_EXT_REF_PTR = *mut av1_ext_ref_frame_t;
pub type aom_codec_control_type_AV1D_EXT_TILE_DEBUG = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_SET_ROW_MT = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_SET_IS_ANNEXB = ::std::os::raw::c_uint;
pub type aom_codec_control_type_AV1D_SET_OPERATING_POINT = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1D_SET_OUTPUT_ALL_LAYERS = ::std::os::raw::c_int;
pub type aom_codec_control_type_AV1_SET_INSPECTION_CALLBACK = *mut aom_inspect_init;
pub type aom_codec_control_type_AV1D_SET_SKIP_FILM_GRAIN = ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_FWD_KF_PRESENT = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_FRAME_FLAGS = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_ALTREF_PRESENT = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_TILE_INFO = *mut aom_tile_info;
pub type aom_codec_control_type_AOMD_GET_SCREEN_CONTENT_TOOLS_INFO =
    *mut aom_screen_content_tools_info;
pub type aom_codec_control_type_AOMD_GET_STILL_PICTURE = *mut aom_still_picture_info;
pub type aom_codec_control_type_AOMD_GET_SB_SIZE = *mut aom_superblock_size_t;
pub type aom_codec_control_type_AOMD_GET_SHOW_EXISTING_FRAME_FLAG = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_S_FRAME_INFO = *mut aom_s_frame_info;
pub type aom_codec_control_type_AOMD_GET_SHOW_FRAME_FLAG = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_BASE_Q_IDX = *mut ::std::os::raw::c_int;
pub type aom_codec_control_type_AOMD_GET_ORDER_HINT = *mut ::std::os::raw::c_uint;
